//Chapter 1

The scripting language and the database are both running q programs,
a q function defined in a script can be sent to the database where it is evaluated and then only the results are returned.
This is a reversal of the paradigm where data is brought to the analytics.
With q, analytics can be sent to the data.

When the results of a vactor operation are used as the inputs of the next operation,
all the data stored in the CPU's memory cache can be accessed immediately without needing
to search in the slower/larger caches or even the slowest and largest RAM memory located on the motherboard.

1.2. What is Q
I will reserve the term operator for any function that is provided by the q language (implemented in C or in q)

1.3 Programming Paradigms
* Q is interpreted because it requires no compilation phase.
ALL FUNCTIONS are compiled into bytecode at run time.
Definitions are compiled at startup and are lazily resolved.
They must be syntactically correct at startup, but the ordering of compilation is not important.

* Q is dynamic in both function definition and variable types (both can be changed at runtime).
This flexibility adds a runtime penalty as both the function def and variable type must be checked for each function call 
* array/vector programming language

* functional (but not pure functional)

* Kdb+ processes can be written as event handlers. Without concurrency, all q functions run in a single main thread.
To enable interaction with other processes q implements the reactor design pattern.
It demultiplexes the concurrent messages and synchronously invokes callbacks.
Responding to multiple asynchronous events allows kdb+ processes to be used as a Complex Event Processor



//Chapter 2
.Q.res - The list of operators defined in C
q).Q.res
`in`within`like`bin`binr`ss`if`do`while`exec`select`insert`update`delete`avg`..

s.k - implentation of an SQL interface for ODBC clients
QHOME is needed to load q.k correctly

In kdb banner, the number of licensed cores appear within the parentheses (
It is possible to reduce the number of cores visible to the q binary on Linux by changing the CPU affinity
with the taskset utility.

q needs k4.lic, by default it looks in the same dir as q.k
QLIC env variable can be usde to customise this

Q then loads q.q from QHOME
QINIT can be used to customise the init file

q web server can return files such as crossdomain.xml or favicon.ico
They can be placed in a QHOME/html (different location can be set with .h.HOME)

//2.2 Basics

#Exiting from Q
- EOF (Ctrl-d Unix / Ctrl-z Windows) exits q session

#q as shebang script
#!/$QHOME/$QARCH/q
we can run ./script.q without referencing q binaries

#toString to console format
- to print the data to console q uses .Q.s

#Redirecting the output from a separate process
When q is started interactively (q console), input is read from the STDIN file handle which is attached to the terminal.
If we redirect the output from a separate process into q's STDIN, it will accept commands from that process instead.
Once EOF is reached, the process will terminate

echo '1 "hello world\n";' | q
hello world

#using k code
\ will switch to k mode
in the source file use k) e.g.
k)myfunc:{...};

\ - exit into k) or exit into q
\ - exit one layer of debuging
\ - exit multi-line comment
\ - exit parsing of source file (everything below are comments)

############################ 2.3 Syntax Rules
k was designed to be an APL-like language but written completely with the ASCII character set.
That's why a lot of operators is overloaded

{} braces or curly brackets
[] brackets
() 

() are not used for function invocation
f(1;2;3) creates a list and does f[(1;2;3)]

#Operator precendence - there is non , statements evaluated from right to left
(2*3)+4 -> 4+2*3
() are used to enforce operator precedence

##Leading whitespaces
q continues to accumulate text for parsing until it finds anohter command starting flush left (no leading whitespaces)
- if we forget to indent every line of a function and q parser encounters a line that is flush left,
it assumes a new definitiona has begun (our unction will be incomplete).


#############################Chapter3
Fundamentally, q has two data types: atoms and lists
- dictionaries and tables are internally represented as combinations of lists
- uniform lists (all the values of a list are the same type) aka vectors 
- kdb performs type checking at runtime, a uniform list only needs its type checked a single time and not for each element,
once the type has been checked, performing arithementic oprations on uniform lists can be implemented in highly optimized C or assembly code

 Atomic functions
 A function is called atomic if it operates on a list of values as if the function was applied to each of the list elements
 
 All arithmentic operators are atomic
 
 #List Length
 Vectors and Non-uniform lists - In all cases, the length of the list is known at all times and stored alongside the data.
 count operator does not count the list items
 With atoms and non-list types, count is 1
 
 #page 24, List Syntax
 Using til to generated ordered int data
 
 Using set/get to dynamically assign/access variables (where name is only known at runtime)
 This works only for global variables
 q)test:2
q){test:20; get `test}[]
2

#Aggregating Functions
An aggregating function always reduces the dimension of the data suplied as its operand
list -> atom
matrix -> list

q)prd 1 2 3
6

3.3 Numeric Random data
5?10 -> range [0;9]
5?0i -> range all integers
5?10f -> range (0.0;10.0)

random numbers no duplicates/replacements
-10?10 (see negative -10)

with temporal types range is
00:00 - 23:59
00:00:00 - 23:59:59
00:00:00.000 - 23:59:59.999
2000.01.01 - 2013.12.31 (1 leap year cycle 1461 days = 1+365x4

q)-11?10
'length /we can't generate 11 distinct integers in that range

* for distinct temporal types we have to cast from integers

q)`minute$-3?10
00:08 00:02 00:04

rand - Singe random value
q)rand 10
9
q)rand
k){*1?x} /first 1?x


#All monadic k operators has been given a keyword in q e.g.
q)first
*:

last is implemented in C
q)last
last

3.4 Non numeric Random Data
It's not ordered so we don't supply max but null

0Nc or " " for chars
q)10?0Nc
"gtooltofin"

q)rand 0Ng
ee846e93-69c9-8697-52cb-20d9f12c9963 //internally vector of bytes

internal K structure is 16 bytes (this is for non numberic data like guid)
8 bytes for metadata type,reference count, attributes
8 bytes to store an atom

To see an atom byte representation
q)0x0 vs 2h   /vector from scalar
0x0002 /short is 2 byte integer number (int16)
integer is int32
long is int64

scalar from vector
q)0x0 sv 0x0002
2h

Random Symbols
q)2?`8 /8 is max length, will get error for 2?`9
`ojjoidhe`bjchodnd  ->[a;p] sample from first 16 characters

Generating strings from predefined lists
q)5?.Q.A
"XMMCE"

.Q.a .Q.A - lower and upper case letters
q).Q.n
"0123456789"
q).Q.nA
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
q).Q.an
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789"

q).Q.b6 - all characters used in 64 encoding
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

3.5
Random seed \S
q)5?10
8 1 9 5 4
q)\S
-314159i
q)5?10
6 6 1 8 5
q)\S -314159i
q)5?10
8 1 9 5 4
q)

If we start Q again we get the same
q)5?10
8 1 9 5 4

system"S" -> system prepends \ for us
\S

system"pwd" /when using os commands we get list of strings, one per row

#################Chapter 4 Functions #########################
Functions
-  can have 1-8 arguments
- niladic functions are called with (::) assigned to the x parameter, x is silently ignored
- void functions return (::)
- functions can modify global state, avoid this, the good practice is to design the functions so that
  - data that needs to be modified is passed as an arg
  - modified values is passed back as a return value from the function
  
  Code like that is easier to maintain
  Functions like that can be executed in parallel (performance gain), they don't modify a global state
  
  4.1  12 Uniforms
  This method generate numbers from the range (-6.0;6.0)
  we get normal random values, mean of 0, standard deviation of 1
  add 12 uniform random variables and subtract 6.
  The sum of independently drawn samples from the same distribution tend to be a normal distribution,
  irrespective of the original distribution
  
q)-6+sum 12?1f
0.5398522

* Tip - rearange operators to reduce the need for parentheses

Function parameters
- if we reference autmatic variable 'z' in the code then funciton will defined as 3 args func even if we don't reference x or y
- Explicitly defining function parameters prevents automatic variables (x y z) from being created
- monadic functions can be called without []
- build in q dyadic functions can use in-fix notation (x op y), this does not work for user functions (unlsess they are added to the .q namespace)
- similarly to monadic functions, List and dictionaries can be indexed without [] brackets as well
This is called Juxtaposition

############## Reference Counts #################
* Q copies, assigns, and passes variables by reference

* All references point to the same underlying data structure until a modification is attmepted

* Once a modification is made, new memory is allocated and the underlying structure is copied

* Any references to the original value remains unaltered

* This model is known as copy-on-write

* Q keeps track of each variable's reference count and deletes the object once the count drops to 0

* We can access the reference count with -16!x

q)a:10 20 30
q)b:a
/now both a and b point to the same object
q)-16!a
2i
q)-16!b
2i
/now we modify b so a points to original object and b points to a new object
q)b,:100
q)-16!a
1i
q)-16!b
1i
q)

#############Cut################
x cut list - cuts the list into matrix with x columns
q)2 cut til 6
0 1
2 3
4 5

sum on matrix
q)sum 2 cut til 6
6 9

/sum is like +/
0 1 + 2 3 = 2 4   + 4 5 =6 9

(0 1)+(2 3)+(4 5)=6 9

q).stat.u12:{-6f+sum x cut (12*x)?1f}
q)avg .stat.u12 10000
-0.004159518
q)sdev .stat.u12 10000
1.009156
q)

dev, var, cov - calculate population deviation, variance and covariance (odchylenie standardowe w populacji?)
sdev, svar, scov - sample dev var and cov (odchylenie standardowe z proby?)
- include Bessel's correction to compute a more accurate estimation of a sample's deviation
- and an unbiased estimate of its variance and covariance

Skew and Kurtosis - see the formulas 
Skew - 3rd order central moment
Kurtosis - 4th order central moment

Q Tip 4.4
* Use compound assignment for increased efficiency
* Each of the single charactre operators has a compound assignment variant

x-:avg x
x:x-avg x /slower

Q passes arguments by reference, in most cases immutable references
Updating a list creates a complete copy of the original data before modifying the structure
x-avg x

if our intention is to assign results back to x we can modify x list in place
- another way to update a data structure without creating a copy is to use "Index Apply" . or @

4.2 Box-Muller

Q Tip 4.5 Limit control flow statements to a single line (to help with debuginin)
- if the code block becomes too long, then move it to a new function

########Throwing Exceptions
'`myError  /using symbol
'"myError" /using strings

take and drop
q)til 5
0 1 2 3 4

q)2#til 5
0 1
q)2_til 5
2 3 4

q)-2#til 5
3 4
q)-2 _ til 5
0 1 2

It is also possible to drop an item from within a list (with a given index)
q)0 1 2 3 4 _ 3
0 1 2 4
q)0 1 2 3 4_3
0 1 2 4
q)


# as shape to build n x m matrix
q)2 3 # til 10
0 1 2
3 4 5
q)

q)2 0N # til 10
0 1 2 3 4
5 6 7 8 9
q)0N 2 # til 10
0 1
2 3
4 5
6 7
8 9
q)

_ as cut

q)0 3 5 8 _ til 10
0 1 2
3 4
5 6 7
8 9
q)0 3 5 8 cut  til 10
0 1 2
3 4
5 6 7
8 9
q)

4.3

sv computes horner's rule (it evaluates Y to base X)
1*10^2 + 5*10^1 + 9*10^0
q)10 sv 1 5 9
159

X may be a list. For example, to convert days, hours, minutes, seconds to seconds:
q)0 24 60 60 sv 2 3 5 7   / 2 days, 3 hours, 5 minutes, 7 seconds
183907

2*24*60*60+3*60*60+5*60+7


/ over adverb
changes a dyadic function into a monadic function that takes a single list of values
- function takes previous value as the first argument and the second will be the next value from the list
-other languages refer to this process as fold, reduce or accumulate
- only the final value is returned
- scan \ returns all intermediate values (very useful for debugging

Exponentially weighted moving average

SMA - Simple moving average, each data point is weighted equily
20 points SMA - Add the price of last 20 point and divide by 20

EMA - Exponential Moving Average
The weighting of each data point is not equal
More weight is given to the most recent data
The weighting decresse as you go further back in time
EMA treats more recent data as more relevent and more important

old pre 3.1 implementation
x-decay factor
y- list of observations

ewma:{{(y*1-x)+z*x}[x]\[y]}
/rearanging opperations
ewma:{{y+x*z-y}[x]\[y]}

over with 3 args
ewma:{{x+y*x}\[first y;1-x;x*y]}

using decay factor as if it was a function (since 3.1)
0 (.9)\ til 5
ewma:{first[y](1f-x)\x*y}


Vector conditional
?[;;]
- accepts a boolean or a list of booleans
- evealutate both y and z (unlikely the $ operator)


#################################################Chapter 5
Code organization

Building the path by using scalar from vector
q)"/" sv ("/tmp";"stat.q")
"/tmp/stat.q"

Q Tip 5.1 Build path names by joining symbols, not character vectors

` sv separates symbols with "."
q)` sv `a`b`c
`a.b.c

` sv can separate symbols with / to create a file path
Joining a list of symbols whose first element is a hndle creates a single file path (it will have platform specific separator)
q)` sv `:/tmp`dir1`dir2`file.txt
`:/tmp/dir1/dir2/file.txt

vs creates a directory handle and trailing file or subdirector
q)` vs `:/tmp/dir1/dir2/file.txt
`:/tmp/dir1/dir2`file.txt

q)` vs `:/tmp/dir1/dir2
`:/tmp/dir1`dir2
q)

####File existence with key
key `:file /returns () if file does not exist
key `:directory /returns () or list of symbols or `symbol$() if empty

IDENTITY VS EQUALITY
~ match is not tolerat when comparing different types
q)0=0f
1b
q)0~0f
0b
q)

####hsym
hsym prepends : to the symbol to create file/network handle

q)hsym `abc
`:abc

Operators relating to the handles start with leading "h"
hopen hclose hdel hcount hsym

NAMESPACES AND DIRECTORIES!!!

QINIT file - q loads the content of the QINIT file on startup
if QINIT is not defined q attempts to load file named q.q

Namespaces
q)qtips.a:1
q)qtips.b:2
q)\v qtips
`s#`a`b
q)qtips
 | ::
a| 1
b| 2
q)

It is just a mapping/dictionary, ` -> :: is added automatically for us

The root namespace (value `.) is designed for data

There is another type of namespace that is designed for functions and related configuration data

These special namespaces are called directories and begin with a single dot "."

Single letter directories are reserved for q

These are all directories loaded from q.k
q)key `
`q`Q`h`j`o

.q - all functions whcih are implemented in k
.Q - utility function for db maintenance
.h - functions for q's builtin web server
.j - jason functions
.o - odbc connectivity

directory .qtips.a:1 vs namespace qtips.a:1

with directories we can change directory with the directory \d command
q)\d .qtips
q.qtips)a:1
q.qtips)\d .
q).qtips
 | ::
a| 1
q)

Accessing global variables from root directory in another namespace
value `..a
`. `.  /juxtaposition
`.[`a] /bracket notation
`.@`a /index operator "@"

a global var is created if we define namespace or directory from within a function
q){abc.a:10}[]
q)abc
 | ::
a| 10
q)

NAMESPACES vs DIRECTORIES
- all directories are namespaces (namespaces are not directories)
- q was designed to store data in namespaces not directories
- directories can not contain views
- automatic logging with the -l flag only records data updated in the root directory
- partitioned databases can not be loaded into directories

SCOPE FUNCTIONS WITH DIRECTOREIS BUT DATASETS WITH NAMESPACES


importing
q)use `.stat.skew
`.

x - symbol e.g. `.stat (whole directory) or `.stat.skew
use:{
  system["d"]  /returns current directory as a dictionary
    upsert
      $[99h=type v:get x; v; (-1#` vs x)!1#v]
 };
 
 q)-1#` vs `.stat.f
,`f

we upsert `f!{} dictionary

#######################$ conditional operator
$[;;]
$[;;...;] - if there are fourth and fifth blocks then the third is treated as an else if condition

Chapter 6 A random walk

Q Tip - Multiply instead of divide
e.g. 0.5*... instead of %2

- q has implemented vector division by an atom as multiplication by the atom's reciprocal /rI'sIpr.k.l/
- when comparing floating numbers q is using equility with tolerance
- two floating point numbers are considered equal if the abs difference is < than 2^-43 * larger number
- The only number equal to zero is 0
- to test for equality without tolerance ALWAYS compare with 0

#########UNIFORM FUNCTIONS#############
- they all end with an s
avgs deltas fills maxs mins prds ratios sums

- like atomic functions a uniform function returns
    -an atom if called with an atom
    -a list of equal length if called with a list
    
prd - aggration function (return last value only)
prds - uniform function (returns all intermediate results)

otther aggration funtions
arg max min prd sum

deltas - each element is the difference between itself and the prior value
ratios- each element is the ratio of itself and the prior value
fills - each element is filled with previous value (nulls are filled, not nulls are unchanged)



###################6.2 Temporal Data
date
time types (minute, second, time(ms), timespan(ns)
minute, second, time are 4-byte integers
timespan is 8-byte integer

timespan like other time data types is a number that represents a window of time
When te value is less than one day it can represent a specific time of day

example when the day is rolled
q)0D23:59:59+`minute$2
1D00:01:59.000000000

###date and time
old type - datetime, 8-byte double (don't use)
new type - timestamp

Q Tip 6.3 Use timestamps instead of datetimes

Where the timespan indicates a duration, the timestamp indicates a specific time
Logically, Subtracting 2 timestamps results in a timespan

6.3 Path gen
- all mathematical operators are atomic (they work with both atomos and vectors

Q tip 
Use the dyadic form of deltas, ratios, differ and prev
defaults are 0, 1, :: and ON respectively
deltas[0;]
ratios[1;]
differ[::;]
prev[0N;]

/deltas to see number of days betwen dates
q)L:2016.06.05 2016.06.08 2016.06.11
q)deltas L / 0 is 2000.01.01
6000 3 3i
q)deltas[first L;L]
0 3 3i
q)

/prev is like right shift?
q)L:2 3 5 7 11
q)prev L
0N 2 3 5 7
q)prev[0; L]
0 2 3 5 7
q)

Ranges

q).Q.addmonths[.z.d;0 2]
2016.06.05 2016.08.05

###Projections
The acto of calling a function with fewer parameters than is needed aka partial application or binding paramters


###Dot Apply

The dot operator "." accepts a multivalent function, projection or data structure as its left operand and a list as its right operand.
- it then calls the function as if it had been called with bracket notation

Chapter 7
Dictionaries
- kdb uses a pair of lists for the idctionary implementation (other languages typically use binary trees/hash tables)

e.g. to map dates to prices
dict:dt!p
- creating a dictionary from lists is a constant time operation, no data has been copied
- key, value retrieve keys and values lists

if we have a list of pairs we can create dictionary
(!) . flip pairs

By default, a binary q operator, such as "!" is an infix dyadic verb. That is, it must be surrounded by left and right operands or called with bracket notation.
To pass it as an argument to the dot apply operator ".", we must convert it into a noun.

- a verb must be passed a noun as an argument
- a noun can be passed as an argument to a verb

Q list operators are overloaded to work on dictionaries

e.g.
2#d - # takes first n elements of a dictonary
subsetOfKeys#d - # returns a dictinary with a subset of keys/values
To take a single element and return as dictionary, we have to enlist
q)(1#2000.05.02)#d
2000.05.02| 98.123

Other value modifying operators ignore the key and update the dictionary's values
Aggregate functions can be applied to the dictionary's values but the results are no longer dictionaries

q)avg dict
103.78

Indexing
- Dictionaries are indexed by value, not position
- both bracket notation and juxtaposition works

DICTIONARY LOOKUPS ARE PERFORMED BY ITERATING OVER EACH KEY ELEMENT UNTIL AN EXACT MATCH IS FOUND and the coresponding value is then returned.

For small dictionaries this can be faster than using more advanced techniques such as binary search or hashing
For bigger ones this linear search will be very slow. (see chapter 8)


Assignment
- to update we can assign directly
d[key]:newValue

- or join with a new dictionary that has the list of new values

Q Tip 7.1 Ensure dictionary keys are unique
- it is possible to introduce duplicate keys
- Q does not prevent us from doing this, looking up a value will only find the first occurrence of each distinct key

Creating a list with single element - enlisting
enlist a
1#a
(),a

Q Tip 7.2 Use 0N! to debug data structures and functions
- this just prints an argument and has no side effects

page 79
Namespaces revisited
directory .qtips.a:1 vs namespace qtips.a:1

namespace/directory is a dictionary that stores variables and functin definitions

We can index into the directory to find the function definition
q).stat`pctile
...

q).stat.pctile

Dot notation is more strict than indexing a namespace, it throws an error if a function is missing
q).stat.missing
'.stat.missing

Indexing just returns generic null (::)

##############7.2 Tables
Table is a flipped dictionary of lists

On a list of lists, the flip operator transposes the values

Similarly, using flip on a dictionary of lists creates a list of dictionaries - a kdb table.
With kdb table we can index by row number to pull the dictionary we want

t 4
or
t[4;`price]

Table is still stored as a dictionary of lists
- Using the plip operator on a matrix does transpose the data (expensive operation)
- Using flip on a dictionary of lists does not transpose the data. It only records the fact that the data should be treated as a table.

Looking at the intrnal representation shows us that it is still a flipped dictionary of lists 
q)0N!t
+`sym`time`v!(`a`b`c;11:40:31.831 11:40:31.832 11:40:31.833;10 10 10)
sym time         v
-------------------
a   11:40:31.831 10
b   11:40:31.832 10
c   11:40:31.833 10
q)

The "+" character is actually the flip operator in K

We can flip dict to table if
- the keys of the dict must be symbols
- each of the list must be of equal size or be an atom which can be coerced into a list /kəʊˈɜːs/ wymuszac

We can create a table by
- flipping a dict
- creating a list of dict
- define ([] c1:data) or ([] c1) if we are happy with column name = variable name

Kdb will always check a list of dictionaries to see if it can be converted to a table (keys symbols,matching column types etc)
Kdb will always convert it to dictionary of lists / table 

To get a list of columns
q)key flip t
`id`date`price

or cols operator - will work with keyed and on-disk tables
//use key flip t in tp code not the cols



# - Taking a subset of cols table
q)enlist[`sym]#t
sym
---
a
b
c
q)

or return as lists
q)t`sym`v
a  b  c
10 10 10

2#t - frist 2 rows

To take first or last few columns we can amend # with /:
table is a list of dictionaries so from each dictionary we take 2# keys and create a list of sub-dictionaries

q)2#/:t
sym time
----------------
a   11:40:31.831
b   11:40:31.832
c   11:40:31.833
q)

In practice, a kdb+ table is not a list of dictionaries, but is a flipped dictionary of lists.
And as such, the "#/:" operator merely performs the constant time operation of taking the first two columns.

7.3 Keyed Tables

Keyed table is a dictionary that maps key table with value table

Just as dictionaries allow us to access values by key, a kayed table allows us to access rows by key as well

- we can define keys within ([...]
or use key ! operator on existing table to indicate the number of keyed columns
2!tbl

if the key columns are not in front, use xcols
2!`id`date xcols tbl

but xkey does both
`id`date xkey t

to unkey
0!tbl
() xkey tbl

-we can also use ! to create a keyed table as a dictionary
kt!t

Indexing the keyed table - Dictionary of tables
q) (0;2000.01.01)
price| 100

to query multiple records
t flip (0;2000.01.01 + til 3)
price
-------
100
98
97

But flipping a list of lists reorders the data in memory
More efficient method of indexing a keyed table is to use a table instead

t ([]id:0;date:2000.01.01 + til 3)
price
-------
100
98
97

See only unkeyed / value table is returned

Remember keyed table is a dictionary that maps key table to value table
- dictionary maps a list of keys to a list of values
- keyed table, the list of keys is a list of dictionaries (a table)
- the list of values is a list of dictionaries (another table)

key kt
value kt 
works as exected, they return respective tables


Chapter 8.1 Looping
each - there is a loop in the underlying implementation
each left \:
each right /:
each both '

Using each left/right/both let us use infix notation with user defined functions just like builtin q operators (can't be done 
with user defined functions when they are not used with an adverb)

ungroup - can be used on a table to ungroup nested lists 

Q Tip 8.1 User array lookups to implement simple conditional statements

("np" t in 12 14 15h)$myTime  /cast to timestamp or timespan

or `time`date[t=14h]

When transforming the result of an if/else statement into one of two elements
it is often easier to perform an array lookup instead of $[;;]

extension to this is using signum, e.g. we want "B"(buy) "S"(sell) or " " based on the sign of the price quantity
prices 10 0 -10
"S B"1+signum 10 0 -10 

raze - creates a list by joining each of the elements of its arguments
- it reduces one layer of nesting

q)raze (10 20 30;100 200)
10 20 30 100 200

q)raze (10;(20 20;30 30);100 200)
10
20 20
30 30
100
200

Q Tip 8.2 Return unkeyed tables by default
It is important that the tables being razed not be keyed
- keyed tables are dictionaries nad joining two dictinaries merges common keys
- so function should return a table then it can be run with each and results razed

8.2 Attributes
- By default, q uses a linear serach algorithm to find values within lists
- Other options we have are: binary search for sorted data, or hashing algorithm for unique, grouped or partitioned data

attr operator obtains the attribute associated with any q value, can return the below. 
To apply attribute we use # with on of the below symbols
`s
`u
`p
`q
`

-we can use `# to remove attributes from a list
`#list

Sort Attribute
- informs q to use a binary search algorithm to find the desired element(s)
- applying `s# to an unsorted list will fail ('s-fail)
- appending an item that invalidates the sorted order will remove the attribute from the list
- asc operation will apply the `s# automatically
- `s# adds no memory overhead to the process
- q never modifies a variable unless we use in-place assighment but behaviour when applying sort attribute is different 

q)x:til 3
q)`u#x
`u#0 1 2
q)x
0 1 2
q)`s#x
`s#0 1 2
q)x
`s#0 1 2
q)
q)`#x
0 1 2
q)x
`s#0 1 2

This trick is used to save memory by avoiding the need to copy the list

10?5 - left argument is an atom => random gen to get 10 itemps
list?10 - left argument is a list => find

measuring with \ts:NoOfRuns ...

Binary Search
- even without the `s# attribute we can force a binary search on sorted data by using the binary search operator bin
- bin returns the index of the right operand
- if the value does not exist bin returns an index of the closest but not larger value
-if data is unsorted the results are undefined

q)10 20 30 bin 30
2
q)10 20 30 bin 25
1
q)
q)10 20 30 binr 25
2

binr returns the index of the value that exists to the right of the non-existing element

#Sorting a table 
`col1`col2 xasc tbl
- Sorting routine is stable, the ordering of equal items remains constant
- xasc will add `s# on col1
- xasc can be used with `tblname to update the table directly (no data copy is needed)
- if tblname is not a global variable then we have to assign the result back to the original variable

Q Tip 8.3
Use \t:n and \ts:n to time multiple runs of a single command

The sort attribute is good for data that has a high number of distinct values all listed in increasing order (e.g. time)
If not sorted or there are many repeated values we can consider the remaining attributes which rely on a hashing algorithm

- u g and p attributes need extra memory and use a hashing algortigh
`u maps the value to a single index
`g maps the value to a list of indices
`p maps the value to an index and count

Unique Attribute

- `u is used with lists that have no duplicate entries
- q uses a hashing algorithm to find the exact index for the desired element
- 'u-fail is thrown if there are duplicates 

We can/should apply the `u attribute to a table that has a single column primary key
We must apply `u on the column vector before creating the keyed table
e.g.

tbl[`id]:`u#tbl`id;
tbl:`id xkey tbl;

Index Apply
- q has a shorthand for indexing into a list, applying an operation to the elements, and assigning the rsults back to the original list

@ was used as index operator to index into a list/dictionary/table
@[t;`date]

@ is also used for index apply
@[t;`date;monadicFunction]
@[t;`price;dyadictFunction;arg]
@[t;`price;%;100]

E.g. amend a column to add an attribue
t:@[t;`date;`u#]

but we don't have to create a new copy of the table. We can use `tblName to amend existing object
q)@[`t;date;`u#]
`t

REMEMBER - use in-place amends to avoid unnecessary data copy
ALSO remember that these in-place amends works only with global variable names
E.g. `t must be global if for the below to work
{
  ...
  @[`t;date;`u#];
 }[]



Q Tip 8.4
Use the `u attribute on dictionary keys to increase perfrormance

By default, looking up a value in a list(and therefore a dictionary) performs a linear search through each of the keys until a match is found. That means that keys at the end of a dictionary will have slower retrieval time than keys at the beginning

* Adding the `u attribute to the keys list changes the lookup method from a linear search to a constant time hashing algorithm.
* For small dictionaries this may make the lookup slower
* For dictionaries with around 80 elements or more, the `u attribute allows data retrieval to remain constant-time

To define this we apply `u# to the keys
q)d:(`u#keys)!values

Note - attributes other than the sort one need extra memory. The extra attribute info is saved into disk when we persist the data

####Partition Attribute
Like the unique attribute `u, the partition attribute `p creates a map
The map maps each unique value to a starting row index and the count 

`p requires all instances of a specific value to be partitioned/clustered together. Sorting is a convenient way to partition a list

####Group attribute
Applying `g to a list causes q to create a mapping from the distinct hash values to a list of row indices.

Used in rdb `g#sym
This ensure fast query times. q updates its internal grouping map whenever new rows are added. This makes each update slower, but ensures fast query performance.

Performance Considerations
To perform a table lookup, q first finds all rows in the table that match according to the first keyed column.
Once all matches are found, it is able to narrow the search for any subsequent columns in the key.
Adding an attribute on the first column of the key allows q to narrow the search (no need for linear search on all rows).
BUT ONCE THE FIRST COLUMN IS USED TO NARROW THE SEARCH, ATTRIBUTES THAT MAY EXISTS ON THE REMAINING COLUMN ARE IGNORED
A LINEAR SEARCH IS USED FOR ALL REMAINING COLUMNS

ALWAYS USE THE MOST DESCRIPTIVE IDENTIFIER (THE BEST FILTER) AS THE FIRST KEYED COLUMN

Q Tip 8.5
Place the most descriptive column first

Performance of a table query depends on how fast q can narrow the search down to a few rows before it resorts to a linear comparison

If you must have multiple columns in the key, ensure the most descriptive identifier is first and prefer the `p over the `g attribute

adding attributes to too many columns may slow down the insert times

Q Tip 8.6
Reapply attributes after filtering or deleting rows from a table
- slecting a subset or deleting rows from tables removes all attributes
- appending rows that invalidate attributes also removes them

sattr function optimally sets attributes on tables with no key, singlek key or multiple keys
- single column key will always have the primary identifier as the first column
- If the table has a single column key, we will apply the unique attribute
- In all other cases we apply the group attribute `g. This inlucdes the case where there is no kay and hwere the key has multiple colummns

Sorted Multi Column Keys
- Indexing into a multi-keyed table tat has many unique values in each column of the key can become quite slow. Once the attribute in the first column is used, a linear search is performed for the remaining columns.

To fix this we can sort the table and add a sort attribute `s to the whole key
- This can inform kdb+ that it can use a binary search algorithm for the composite key
- We have to write our own function because asc operator sorts dictionaries by value not key

kasc:{
  $[`sattr k:key x;
    x; /return here if the key table is already sorted
    (`s#k i)!value[x]i:iasc k
   ]
 };

- iasc operator determine the proper transfromation needed to sort the key
The iasc operator performs the work behind both asc and xasc
Instead of actually rearranging the order of list elements, the iasc operator returns the index where each properly sorted element can be found in the original list

The asc operator uses these indices to index into the original list, thus returning a sorted copy
The benefit of separating out this functionality is that the results of iasc can be used to sort other lists without having to recompute the sort order

our kasc uses the results of iasc to reorder both the kay and value tables of the supplied dictionary
k:key x
(`s#k i)!value[x]i 

then at the end we place sort attribute on the key

***check what it means to place `s on the table
q)a:10 20 30
q)b:`a`b`c

q)0N!`s#([]a;b)
`s#+`a`b!(`p#10 20 30;`a`b`c)
a  b
----
10 a
20 b
30 c
q)

/we can see applying `s# on a table does the following
- places `s# on entire table
- places `p# on the first column

q)meta `s#([]a;b)
c| t f a
-| -----
a| j   p
b| s
q)

*** check how this works on dictionaries
q)kasc:{$[`s=attr k:key x;x;(`s#k i)!value[x]i:iasc k]};
/we see `s# is applied on key list
q)d:0N!kasc a!b;
`s#10 20 30!100 200 300
q)d
10| 100
20| 200
30| 300
q)d 10
100
q)d 15
0N

Chapter 9 Trades and Quotes

Minimize calls to each

E.g. assume we have a function which generate a list and we can use it to generate a list of lists with each
q)genList 5
4 3 2 1 0
q)genList each 3#5
4 3 2 1 0
4 3 2 1 0
4 3 2 1 0
q)

Now we need to sort each of the lists
q)asc each genList each 3#5
0 1 2 3 4
0 1 2 3 4
0 1 2 3 4
q)

we used 2 each to do that. We can use lambda or composition with @ to minimize calls to each

1) Using lambda
q){asc genList x} each 3#5
0 1 2 3 4
0 1 2 3 4
0 1 2 3 4
q)

2) Using composition
q)(asc genList@) each 3#5
0 1 2 3 4
0 1 2 3 4
0 1 2 3 4
q)

We use () and @ to force the creation of function composition before it is applied to each argument
- since @ operator expects another argument the contents of () can not be fully evaluated 
- the results is therefore a function composition expecting a single argument
- composition - joining of 2 functions to create a third function
- the left most function must be mondadic (asc)

q)type (genList@)
104h //projection
q)type (asc genList@)
105h //composition

' operator can be used to create a composition (first function must be monadic)
q)'[asc;genList] each 3#5
0 1 2 3 4
0 1 2 3 4
0 1 2 3 4

9.2 Quotes
Step Function - can be created with dictionaries by applying `s# on a dictionary (not just on its key)

q)k:0N 5 10 25 50 100
q)0N!sf:`s#k!v
`s#`s#0N 5 10 25 50 100!0.01 0.05 0.1 0.25 0.5 1
   | 0.01
5  | 0.05
10 | 0.1
25 | 0.25
50 | 0.5
100| 1

q)sf 5
0.05
q)sf 6  //would gen null here without `s# on the dict
0.05
q)sf -10
0.01
q)

The sort attribute distinguishes the step function from an ordinary dictionary.
It was added in two places: on dictionary's key and on the dictionary itself
- it is the very first attribute (on dictionary) that allows the dictionary to be treated as a strep function.
When we index into the dictionary/step function, q will perform a binary search and return the value associated with the proper key location.

standard dictionary indexing is
/x - dictionary
/y - a key value
di:{value[x] key[x] ? y}

step function indexing
/x - dictionary
/y - a key value
sfi:{value[x] key[x] bin y}

The same applies to a keyed tables
We can see the `s# is applied to the keyed table as a whole, in addition to the dicctionary's key (a table) and also to the first column of the key
q)0N!kt:`s#([k]v)
`s#(`s#+(,`k)!,`s#0N 5 10 25 50 100)!+(,`v)!,0.01 0.05 0.1 0.25 0.5 1
k  | v
---| ----
   | 0.01
5  | 0.05
10 | 0.1
25 | 0.25
50 | 0.5
100| 1
q)

q)kt 15
v| 0.1
q)

Rounding to the Nearest Tick

Extending a table, using ,' instead of update
e.g. we have table wiht `id`time`pirce columns and want to add moving averages for windows of 2 4 6
q)p:([]price:til 20)

q)w:2 4 6
q)p,'flip (`$"w",/:string w)!w mavg\: p`price
price w2   w4   w6
--------------------
0     0    0    0
1     0.5  0.5  0.5
2     1.5  1    1
3     2.5  1.5  1.5
4     3.5  2.5  2
...


To pick only the columns we want
tbl:`id`time`price#tbl;

9.3 Trades

next - shift left
prev, xprev - shift right

using prev/shift right is very common with time series data
q)2 xprev til 5
0N 0N 0 1 2
q)

There is not xnext but we can use xprev with a negative left operand

Casting Between Types
Casting between types ($) can be done with a symbol, character, or numeric representation of the type.
q)7h$0.4 2.5 3.9
0 3 4
q)

Grouping and razing

raze (...@) each q group q`id
When the eached function returns a result that is smaller than the orginally grouped table, performance improvements can be made by generating the grouped table within the function or composition, and not aoutside
raze (... q@) each group q`id

This prevents apotentially large allocation of temporary memory.

See Chapter 10 in new file
