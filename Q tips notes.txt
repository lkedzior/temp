//Chapter 1

The scripting language and the database are both running q programs,
a q function defined in a script can be sent to the database where it is evaluated and then only the results are returned.
This is a reversal of the paradigm where data is brought to the analytics.
With q, analytics can be sent to the data.

When the results of a vactor operation are used as the inputs of the next operation,
all the data stored in the CPU's memory cache can be accessed immediately without needing
to search in the slower/larger caches or even the slowest and largest memory sotre located on the motherboard.

1.2. What is Q
I will reserve the term operator for any function that is provided by the q language (implemented in C or in q)

1.3 Programming Paradigms
* Q is interpreted because it requires no compilation phase.
ALL FUNCTIONS are compiled into bytecode at run time.
Definitions are compiled at startup and are lazily resolved.
They must be syntactically correct at startup, but the ordering of compilation is not important.

* Q is dynamic in both function definition and variable types (both can be changed at runtime).
This flexibility adds a runtime penalty as both the function def and variable type must be checked for each function call 
* array/vector programming language

* functional (but not pure functional)

* Kdb+ processes can be written as event handlers. Without concurrency, all q functions run in a single main thread.
To enable interaction with other processes q implements the reactor design pattern.
It demultiplexes the concurrent messages and synchronously inokes callbacks.
Responding to multiple asynchronous events allows kdb+ processes to be used as a Complex Event Processor



//Chapter 2
.Q.res - The list of operators defined in C
q).Q.res
`in`within`like`bin`binr`ss`if`do`while`exec`select`insert`update`delete`avg`..

s.k - implentation of an SQL interface for ODBC clients
QHOME is needed to load q.k correctly

In kdb banner, the number of licensed cores appear within the parentheses (
It is possible to reduce the number of cores visible to the q binary on Linux by changing the CPU affinity with the taskset utility.

q needs k4.lic, by default it looks in the same dir as q.k
QLIC env variable can be usde to customise this

Q then loads q.q from QHOME
QINIT can be used to customise the init file

q web server can return files such as crossdomain.xml or favicon.ico
They can be placed in a QHOME/html (different location can be set with .h.HOME)

//2.2 Basics

#Exiting from Q
- EOF (Ctrl-d Unix / Ctrl-z Windows) exits q session

#q as shebang script
#!/$QHOME/$QARCH/q
we can run ./script.q without referencing q binaries

#toString to console format
- to print the data to console q uses .Q.s

#Redirecting the output from a separate process
When q is started interactively (q console), input is read from the STDIN file handle which is attached to the terminal.
If we redirect the output from a separate process into q's STDIN, it will accept commands from that process instead.
Once EOF is reached, the process will terminate

echo '1 "hello world\n";' | q
hello world

#using k code
\ will switch to k mode
in the source file use k) e.g.
k)myfunc:{...};

\ - exit into k) or exit into q
\ - exit one layer of debuging
\ - exit multi-line comment
\ - exit parsing of source file (everything below are comments)

############################ 2.3 Syntax Rules
k was designed to be an APL-like language but written completely with the ASCII character set.
That's why a lot of operators is overloaded

{} braces or curly brackets
[] brackets
() 

() are not used for function invocation
f(1;2;3) creates a list and does f[(1;2;3)]

#Operator precendence - there is non , statements evaluated from right to left
(2*3)+4 -> 4+2*3
() are used to enforce operator precedence

##Leading whitespaces
q continues to accumulate text for parsing until it finds anohter command starting flush left (no leading whitespaces)
- if we forget to indent every line of a function and q parser encounters a line that is flush left, it assumes a new definitiona has begun (our unction will be incomplete).


#############################Chapter3
Fundamentally, q has two data types: atoms and lists
- dictionaries and tables are internally represented as combinations of lists
- uniform lists (all the values of a list are the same type) aka vectors 
- kdb performs type checking at runtime, a uniform list only needs its type checked a single time and not for each element,
once the type has been checked, performing arithementic oprations on uniform lists can be implemented in highly optimized C or assembly code

 Atomic functions
 A function is called atomic if it operates on a list of values as if the function was applied to each of the list elements
 
 All arithmentic operators are atomic
 
 #List Length
 Vectors and Non-uniform lists - In all cases, the length of the list is known at all times and stored alongside the data.
 count operator does not count the list items
 With atoms and non-list types, count is 1
 
 #page 24, List Syntax
 Using til to generated ordered int data
 
 Using set/get to dynamically assign/access variables (where name is only known at runtime)
 This works only for global variables
 q)test:2
q){test:20; get `test}[]
2

#Aggregating Functions
An aggregating function always reduces the dimension of the data suplied as its operand
list -> atom
matrix -> list

q)prd 1 2 3
6

3.3 Numeric Random data
5?10 -> range [0;9]
5?0i -> range all integers
5?10f -> range (0.0;10.0)

random numbers no duplicates/replacements
-10?10 (see negative -10)

with temporal types range is
00:00 - 23:59
00:00:00 - 23:59:59
00:00:00.000 - 23:59:59.999
2000.01.01 - 2013.12.31 (1 leap year cycle 1461 days = 1+365x4

q)-11?10
'length /we can't generate 11 distinct integers in that range

* for distinct temporal types we have to cast from integers

q)`minute$-3?10
00:08 00:02 00:04

rand - Singe random value
q)rand 10
9
q)rand
k){*1?x} /first 1?x


#All monadic k operators has been given a keyword in q e.g.
q)first
*:

last is implemented in C
q)last
last

3.4 Non numeric Random Data
It's not ordered so we don't supply max but null

0Nc or " " for chars
q)10?0Nc
"gtooltofin"

q)rand 0Ng
ee846e93-69c9-8697-52cb-20d9f12c9963 //internally vector of bytes

internal K structure is 16 bytes
8 bytes for metadata type,reference count, attributes
8 bytes to store an atom

To see an atom byte representation
q)0x0 vs 2h   /vector from scalar
0x0002 /2 bytes out of 8 available bytes within K structure is used

scalar from vector
q)0x0 sv 0x0002
2h

Random Symbols
q)2?`8 /8 is max length, will get error for 2?`9
`ojjoidhe`bjchodnd  ->[a;p] sample from first 16 characters

Generating strings from predefined lists
q)5?.Q.A
"XMMCE"

.Q.a .Q.A - lower and upper case letters
q).Q.n
"0123456789"
q).Q.nA
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
q).Q.an
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789"

q).Q.b6 - all characters used in 64 encoding
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

3.5
Random seed \S
q)5?10
8 1 9 5 4
q)\S
-314159i
q)5?10
6 6 1 8 5
q)\S -314159i
q)5?10
8 1 9 5 4
q)

If we start Q again we get the same
q)5?10
8 1 9 5 4

system"S" -> system prepends \ for us
\S

system"pwd" /when using os commands we get list of strings, one per row

#################Chapter 4 Functions #########################
Functions
-  can have 1-8 arguments
- niladic functions are called with (::) assigned to the x parameter, x is silently ignored
- void functions return (::)
- functions can modify global state, avoid this, the good practice is to design the functions so that
  - data that needs to be modified is passed as an arg
  - modified values is passed back as a return value from the function
  
  Code like that is easier to maintain
  Functions like that can be executed in parallel (performance gain), they don't modify a global state
  
  4.1  12 Uniforms
  This method generate numbers from the range (-6.0;6.0)
  we get normal random values, mean of 0, standard deviation of 1
  add 12 uniform random variables and subtract 6.
  The sum of independently drawn samples from the same distribution tend to be a normal distribution,
  irrespective of the original distribution
  
q)-6+sum 12?1f
0.5398522

* Tip - rearange operators to reduce the need for parentheses

Function parameters
- if we reference autmatic variable 'z' in the code then funciton will defined as 3 args func even if we don't reference x or y
- Explicitly defining function parameters prevents automatic variables (x y z) from being created
- monadic functions can be called without []
- build in q dyadic functions can use in-fix notation (x op y), this does not work for user functions (unlsess they are added to the .q namespace)
- similarly to monadic functions, List and dictionaries can be indexed without [] brackets as well
This is called Juxtaposition

############## Reference Counts #################
* Q copies, assigns, and passes variables by reference

* All references point to the same underlying data structure until a modification is attmepted

* Once a modification is made, new memory is allocated and the underlying structure is copied

* Any references to the original value remains unaltered

* This model is known as copy-on-write

* Q keeps track of each variable's reference count and deletes the object once the count drops to 0

* We can access the reference count with -16!x

q)a:10 20 30
q)b:a
/now both a and b point to the same object
q)-16!a
2i
q)-16!b
2i
/now we modify b so a points to original object and b points to a new object
q)b,:100
q)-16!a
1i
q)-16!b
1i
q)

#############Cut################
x cut list - cuts the list into matrix with x columns
q)2 cut til 6
0 1
2 3
4 5

sum on matrix
q)sum 2 cut til 6
6 9

(0 1)+(2 3)+(4 5)=6 9

q).stat.u12:{-6f+sum x cut (12*x)?1f}
q)avg .stat.u12 10000
-0.004159518
q)sdev .stat.u12 10000
1.009156
q)

dev, var, cov - calculate population deviation, variance and covariance (odchylenie standardowe w populacji?)
sdev, svar, scov - sample dev var and cov (odchylenie standardowe z proby?)
- include Bessel's correction to compute a more accurate estimation of a sample's deviation
- and an unbiased estimate of its variance and covariance

Skew and Kurtosis - see the formulas 
Skew - 3rd order central moment
Kurtosis - 4th order central moment

Q Tip 4.4
* Use compound assignment for increased efficiency
* Each of the single charactre operators has a compound assignment variant

x-:avg x
x:x-avg x /slower

Q passes arguments by reference, in most cases immutable references
Updating a list creates a complete copy of the original data before modifying the structure
x-avg x

if our intention is to assign results back to x we can modify x list in place
- another way to update a data structure without creating a copy is to use "Index Apply" . or @

4.2 Box-Muller

Q Tip 4.5 Limit control flow statements to a single line (to help with debuginin)
- if the code block becomes too long, then move it to a new function

########Throwing Exceptions
'`myError  /using symbol
'"myError" /using strings

take and drop
q)til 5
0 1 2 3 4

q)2#til 5
0 1
q)2_til 5
2 3 4

q)-2#til 5
3 4
q)-2 _ til 5
0 1 2

It is also possible to drop an item from within a list (with a given index)
q)0 1 2 3 4 _ 3
0 1 2 4
q)0 1 2 3 4_3
0 1 2 4
q)


# as shape to build n x m matrix
q)2 3 # til 10
0 1 2
3 4 5
q)

q)2 0N # til 10
0 1 2 3 4
5 6 7 8 9
q)0N 2 # til 10
0 1
2 3
4 5
6 7
8 9
q)

_ as cut

q)0 3 5 8 _ til 10
0 1 2
3 4
5 6 7
8 9
q)0 3 5 8 cut  til 10
0 1 2
3 4
5 6 7
8 9
q)

4.3

sv computes horner's rule (it evaluates Y to base X)
1*10^2 + 5*10^1 + 9*10^0
q)10 sv 1 5 9
159

X may be a list. For example, to convert days, hours, minutes, seconds to seconds:
q)0 24 60 60 sv 2 3 5 7   / 2 days, 3 hours, 5 minutes, 7 seconds
183907

/ over adverb
changes a dyadic function into a monadic function that takes a single list of values
- function takes previous value as the first argument and the second will be the next value from the list
-other languages refer to this process as fold, reduce or accumulate
- only the final value is returned
- scan \ returns all intermediate values (very useful for debugging

Exponentially weighted moving average

SMA - Simple moving average, each data point is weighted equily
20 points SMA - Add the price of last 20 point and divide by 20

EMA - Exponential Moving Average
The weighting of each data point is not equal
More weight is given to the most recent data
The weighting decresse as you go further back in time
EMA treats more recent data as more relevent and more important

old pre 3.1 implementation
x-decay factor
y- list of observations

ewma:{{(y*1-x)+z*x}[x]\[y]}
/rearanging opperations
ewma:{{y+x*z-y}[x]\[y]}

over with 3 args
ewma:{{x+y*x}\[first y;1-x;x*y]}

using decay factor as if it was a function (since 3.1)
0 (.9)\ til 5
ewma:{first[y](1f-x)\x*y}


Vector conditional
?[;;]
- accepts a boolean or a list of booleans
- evealutate both y and z (unlikely the $ operator)


#################################################Chapter 5
Code organization

Building the path by using scalar from vector
q)"/" sv ("/tmp";"stat.q")
"/tmp/stat.q"

Q Tip 5.1 Build path names by joining symbols, not character vectors

` sv separates symbols with "."
q)` sv `a`b`c
`a.b.c

` sv can separate symbols with / to create a file path
Joining a list of symbols whose first element is a hndle creates a single file path (it will have platform specific separator)
q)` sv `:/tmp`dir1`dir2`file.txt
`:/tmp/dir1/dir2/file.txt

vs creates a directory handle and trailing file or subdirector
q)` vs `:/tmp/dir1/dir2/file.txt
`:/tmp/dir1/dir2`file.txt

q)` vs `:/tmp/dir1/dir2
`:/tmp/dir1`dir2
q)

####File existence with key
key `:file /returns () if file does not exist
key `:directory /returns () or list of symbols or `symbol$() if empty

IDENTITY VS EQUALITY
~ match is not tolerat when comparing different types
q)0=0f
1b
q)0~0f
0b
q)

####hsym
hsym prepends : to the symbol to create file/network handle

q)hsym `abc
`:abc

Operators relating to the handles start with leading "h"
hopen hclose hdel hcount hsym

NAMESPACES AND DIRECTORIES!!!

QINIT file - q loads the content of the QINIT file on startup
if QINIT is not defined q attempts to load file named q.q

Namespaces
q)qtips.a:1
q)qtips.b:2
q)\v qtips
`s#`a`b
q)qtips
 | ::
a| 1
b| 2
q)

It is just a mapping/dictionary, ` -> :: is added automatically for us

The root namespace (value `.) is designed for data

There is another type of namespace that is designed for functions and related configuration data

These special namespaces are called directories and begin with a single dot "."

Single letter directories are reserved for q

These are all directories loaded from q.k
q)key `
`q`Q`h`j`o

.q - all functions whcih are implemented in k
.Q - utility function for db maintenance
.h - functions for q's builtin web server
.j - jason functions
.o - odbc connectivity

directory .qtips.a:1 vs namespace qtips.a:1

with directories we can change directory with the directory \d command
q)\d .qtips
q.qtips)a:1
q.qtips)\d .
q).qtips
 | ::
a| 1
q)

Accessing global variables from root directory in another namespace
value `..a
`. `.  /juxtaposition
`.[`a] /bracket notation
`.@`a /index operator "@"

a global var is created if we define namespace or directory from within a function
q){abc.a:10}[]
q)abc
 | ::
a| 10
q)

NAMESPACES vs DIRECTORIES
- all directories are namespaces (namespaces are not directories)
- q was designed to store data in namespaces not directories
- directories can not contain views
- automatic logging with the -l flag only records data updated in the root directory
- partitioned databases can not be loaded into directories

SCOPE FUNCTIONS WITH DIRECTOREIS BUT DATASETS WITH NAMESPACES


importing
q)use `.stat.skew
`.

x - symbol e.g. `.stat (whole directory) or `.stat.skew
use:{
  system["d"]  /returns current directory as a dictionary
    upsert
      $[99h=type v:get x; v; (-1#` vs x)!1#v]
 };
 
 q)-1#` vs `.stat.f
,`f

we upsert `f!{} dictionary

#######################$ conditional operator
$[;;]
$[;;...;] - if there are fourth and fifth blocks then the third is treated as an else if condition

Chapter 6 A random walk
