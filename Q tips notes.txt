//Chapter 1

The scripting language and the database are both running q programs,
a q function defined in a script can be sent to the database where it is evaluated and then only the results are returned.
This is a reversal of the paradigm where data is brought to the analytics.
With q, analytics can be sent to the data.

When the results of a vactor operation are used as the inputs of the next operation,
all the data stored in the CPU's memory cache can be accessed immediately without needing
to search in the slower/larger caches or even the slowest and largest memory sotre located on the motherboard.

1.2. What is Q
I will reserve the term operator for any function that is provided by the q language (implemented in C or in q)

1.3 Programming Paradigms
* Q is interpreted because it requires no compilation phase.
ALL FUNCTIONS are compiled into bytecode at run time.
Definitions are compiled at startup and are lazily resolved.
They must be syntactically correct at startup, but the ordering of compilation is not important.

* Q is dynamic in both function definition and variable types (both can be changed at runtime).
This flexibility adds a runtime penalty as both the function def and variable type must be checked for each function call 
* array/vector programming language

* functional (but not pure functional)

* Kdb+ processes can be written as event handlers. Without concurrency, all q functions run in a single main thread.
To enable interaction with other processes q implements the reactor design pattern.
It demultiplexes the concurrent messages and synchronously inokes callbacks.
Responding to multiple asynchronous events allows kdb+ processes to be used as a Complex Event Processor


//Chapter 2
.Q.res - The list of operators defined in C
q).Q.res
`in`within`like`bin`binr`ss`if`do`while`exec`select`insert`update`delete`avg`..

s.k - implentation of an SQL interface for ODBC clients
QHOME is needed to load q.k correctly

In kdb banner, the number of licensed cores appear within the parentheses (
It is possible to reduce the number of cores visible to the q binary on Linux by changing the CPU affinity with the taskset utility.

q needs k4.lic, by default it looks in the same dir as q.k
QLIC env variable can be usde to customise this

Q then loads q.q from QHOME
QINIT can be used to customise the init file

q web server can return files such as crossdomain.xml or favicon.ico
They can be placed in a QHOME/html (different location can be set with .h.HOME)

//2.2 Basics

#Exiting from Q
- EOF (Ctrl-d Unix / Ctrl-z Windows) exits q session

#q as shebang script
#!/$QHOME/$QARCH/q
we can run ./script.q without referencing q binaries

#toString to console format
- to print the data to console q uses .Q.s

#Redirecting the output from a separate process
When q is started interactively (q console), input is read from the STDIN file handle which is attached to the terminal.
If we redirect the output from a separate process into q's STDIN, it will accept commands from that process instead.
Once EOF is reached, the process will terminate

echo '1 "hello world\n";' | q
hello world

#using k code
\ will switch to k mode
in the source file use k) e.g.
k)myfunc:{...};

\ - exit into k) or exit into q
\ - exit one layer of debuging
\ - exit multi-line comment
\ - exit parsing of source file (everything below are comments)

############################ 2.3 Syntax Rules
k was designed to be an APL-like language but written completely with the ASCII character set.
That's why a lot of operators is overloaded

{} braces or curly brackets
[] brackets
() 

() are not used for function invocation
f(1;2;3) creates a list and does f[(1;2;3)]

#Operator precendence - there is non , statements evaluated from right to left
(2*3)+4 -> 4+2*3
() are used to enforce operator precedence

##Leading whitespaces
q continues to accumulate text for parsing until it finds anohter command starting flush left (no leading whitespaces)
- if we forget to indent every line of a function and q parser encounters a line that is flush left, it assumes a new definitiona has begun (our unction will be incomplete).


#############################Chapter3
Fundamentally, q has two data types: atoms and lists
- dictionaries and tables are internally represented as combinations of lists
- uniform lists (all the values of a list are the same type) aka vectors 
- kdb performs type checking at runtime, a uniform list only needs its type checked a single time and not for each element,
once the type has been checked, performing arithementic oprations on uniform lists can be implemented in highly optimized C or assembly code

 Atomic functions
 A function is called atomic if it operates on a list of values as if the function was applied to each of the list elements
 
 All arithmentic operators are atomic
 
 #List Length
 Vectors and Non-uniform lists - In all cases, the length of the list is known at all times and stored alongside the data.
 count operator does not count the list items
 With atoms and non-list types, count is 1
 
 #page 24, List Syntax
 Using til to generated ordered int data
 
 Using set/get to dynamically assign/access variables (where name is only known at runtime)
 This works only for global variables
 q)test:2
q){test:20; get `test}[]
2

#Aggregating Functions
An aggregating function always reduces the dimension of the data suplied as its operand
list -> atom
matrix -> list

q)prd 1 2 3
6

3.3 Numeric Random data
5?10 -> range [0;9]
5?0i -> range all integers
5?10f -> range (0.0;10.0)

random numbers no duplicates/replacements
-10?10 (see negative -10)

with temporal types range is
00:00 - 23:59
00:00:00 - 23:59:59
00:00:00.000 - 23:59:59.999
2000.01.01 - 2013.12.31 (1 leap year cycle 1461 days = 1+365x4

q)-11?10
'length /we can't generate 11 distinct integers in that range

* for distinct temporal types we have to cast from integers

q)`minute$-3?10
00:08 00:02 00:04

rand - Singe random value
q)rand 10
9
q)rand
k){*1?x} /first 1?x


#All monadic k operators has been given a keyword in q e.g.
q)first
*:

last is implemented in C
q)last
last

3.4 Non numeric Random Data
It's not ordered so we don't supply max but null

0Nc or " " for chars
q)10?0Nc
"gtooltofin"

q)rand 0Ng
ee846e93-69c9-8697-52cb-20d9f12c9963 //internally vector of bytes

internal K structure is 16 bytes
8 bytes for metadata type,reference count, attributes
8 bytes to store an atom

To see an atom byte representation
q)0x0 vs 2h   /vector from scalar
0x0002 /2 bytes out of 8 available bytes within K structure is used

scalar from vector
q)0x0 sv 0x0002
2h

Random Symbols
q)2?`8 /8 is max length, will get error for 2?`9
`ojjoidhe`bjchodnd  ->[a;p] sample from first 16 characters

Generating strings from predefined lists
q)5?.Q.A
"XMMCE"

.Q.a .Q.A - lower and upper case letters
q).Q.n
"0123456789"
q).Q.nA
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
q).Q.an
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789"

q).Q.b6 - all characters used in 64 encoding
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

3.5
Random seed \S
q)5?10
8 1 9 5 4
q)\S
-314159i
q)5?10
6 6 1 8 5
q)\S -314159i
q)5?10
8 1 9 5 4
q)

If we start Q again we get the same
q)5?10
8 1 9 5 4

system"S" -> system prepends \ for us
\S

system"pwd" /when using os commands we get list of strings, one per row

#################Chapter 4 Functions #########################
Functions
-  can have 1-8 arguments
- niladic functions are called with (::) assigned to the x parameter, x is silently ignored
- void functions return (::)
- functions can modify global state, avoid this, the good practice is to design the functions so that
  - data that needs to be modified is passed as an arg
  - modified values is passed back as a return value from the function
  
  Code like that is easier to maintain
  Functions like that can be executed in parallel (performance gain), they don't modify a global state
  
  4.1  12 Uniforms
  This method generate numbers from the range (-6.0;6.0)
  we get normal random values, mean of 0, standard deviation of 1
  add 12 uniform random variables and subtract 6.
  The sum of independently drawn samples from the same distribution tend to be a normal distribution,
  irrespective of the original distribution
  
q)-6+sum 12?1f
0.5398522

* Tip - rearange operators to reduce the need for parentheses

Function parameters
- if we reference autmatic variable 'z' in the code then funciton will defined as 3 args func even if we don't reference x or y
- Explicitly defining function parameters prevents automatic variables (x y z) from being created
- monadic functions can be called without []
- build in q dyadic functions can use in-fix notation (x op y), this does not work for user functions (unlsess they are added to the .q namespace)
- similarly to monadic functions, List and dictionaries can be indexed without [] brackets as well
This is called Juxtaposition

############## Reference Counts #################
* Q copies, assigns, and passes variables by reference

* All references point to the same underlying data structure until a modification is attmepted

* Once a modification is made, new memory is allocated and the underlying structure is copied

* Any references to the original value remains unaltered

* This model is known as copy-on-write

* Q keeps track of each variable's reference count and deletes the object once the count drops to 0

* We can access the reference count with -16!x

q)a:10 20 30
q)b:a
/now both a and b point to the same object
q)-16!a
2i
q)-16!b
2i
/now we modify b so a points to original object and b points to a new object
q)b,:100
q)-16!a
1i
q)-16!b
1i
q)


