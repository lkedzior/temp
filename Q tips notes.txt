//Chapter 1

The scripting language and the database are both running q programs,
a q function defined in a script can be sent to the database where it is evaluated and then only the results are returned.
This is a reversal of the paradigm where data is brought to the analytics.
With q, analytics can be sent to the data.

When the results of a vactor operation are used as the inputs of the next operation,
all the data stored in the CPU's memory cache can be accessed immediately without needing
to search in the slower/larger caches or even the slowest and largest memory sotre located on the motherboard.

1.2. What is Q
I will reserve the term operator for any function that is provided by the q language (implemented in C or in q)

1.3 Programming Paradigms
* Q is interpreted because it requires no compilation phase.
ALL FUNCTIONS are compiled into bytecode at run time.
Definitions are compiled at startup and are lazily resolved.
They must be syntactically correct at startup, but the ordering of compilation is not important.

* Q is dynamic in both function definition and variable types (both can be changed at runtime).
This flexibility adds a runtime penalty as both the function def and variable type must be checked for each function call 
* array/vector programming language

* functional (but not pure functional)

* Kdb+ processes can be written as event handlers. Without concurrency, all q functions run in a single main thread.
To enable interaction with other processes q implements the reactor design pattern.
It demultiplexes the concurrent messages and synchronously inokes callbacks.
Responding to multiple asynchronous events allows kdb+ processes to be used as a Complex Event Processor


//Chapter 2
.Q.res - The list of operators defined in C
q).Q.res
`in`within`like`bin`binr`ss`if`do`while`exec`select`insert`update`delete`avg`..

s.k - implentation of an SQL interface for ODBC clients
QHOME is needed to load q.k correctly

In kdb banner, the number of licensed cores appear within the parentheses (
It is possible to reduce the number of cores visible to the q binary on Linux by changing the CPU affinity with the taskset utility.

q needs k4.lic, by default it looks in the same dir as q.k
QLIC env variable can be usde to customise this

Q then loads q.q from QHOME
QINIT can be used to customise the init file

q web server can return files such as crossdomain.xml or favicon.ico
They can be placed in a QHOME/html (different location can be set with .h.HOME)

//2.2 Basics

#Exiting from Q
- EOF (Ctrl-d Unix / Ctrl-z Windows) exits q session

#q as shebang script
#!/$QHOME/$QARCH/q
we can run ./script.q without referencing q binaries

#toString to console format
- to print the data to console q uses .Q.s

#Redirecting the output from a separate process
When q is started interactively (q console), input is read from the STDIN file handle which is attached to the terminal.
If we redirect the output from a separate process into q's STDIN, it will accept commands from that process instead.
Once EOF is reached, the process will terminate

echo '1 "hello world\n";' | q
hello world

#using k code
\ will switch to k mode
in the source file use k) e.g.
k)myfunc:{...};

\ - exit into k) or exit into q
\ - exit one layer of debuging
\ - exit multi-line comment
\ - exit parsing of source file (everything below are comments)

############################ 2.3 Syntax Rules
k was designed to be an APL-like language but written completely with the ASCII character set.
That's why a lot of operators is overloaded

{} braces or curly brackets
[] brackets
() 

() are not used for function invocation
f(1;2;3) creates a list and does f[(1;2;3)]

#Operator precendence - there is non , statements evaluated from right to left
(2*3)+4 -> 4+2*3
() are used to enforce operator precedence

##Leading whitespaces
q continues to accumulate text for parsing until it finds anohter command starting flush left (no leading whitespaces)
- if we forget to indent every line of a function and q parser encounters a line that is flush left, it assumes a new definitiona has begun (our unction will be incomplete).


#############################Chapter3
Fundamentally, q has two data types: atoms and lists
- dictionaries and tables are internally represented as combinations of lists
- uniform lists (all the values of a list are the same type) aka vectors 
- kdb performs type checking at runtime, a uniform list only needs its type checked a single time and not for each element,
once the type has been checked, performing arithementic oprations on uniform lists can be implemented in highly optimized C or assembly code

 Atomic functions
 A function is called atomic if it operates on a list of values as if the function was applied to each of the list elements
 
 All arithmentic operators are atomic
 
 #List Length
 Vectors and Non-uniform lists - In all cases, the length of the list is known at all times and stored alongside the data.
 count operator does not count the list items
 With atoms and non-list types, count is 1
 
 #page 24, List Syntax
