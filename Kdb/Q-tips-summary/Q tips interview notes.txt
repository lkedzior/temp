With q, analytics can be sent to the data.

When the results of a vector operation are used as the inputs of the next operation,
all the data stored in the CPU's memory cache can be accessed immediately without needing
to search in the slower/larger caches or even the slowest and largest RAM memory located on the motherboard.

1.3 Programming Paradigms
* Q is interpreted because it requires no compilation phase.
ALL FUNCTIONS are compiled into bytecode at run time.
Definitions are compiled at startup and are lazily resolved.
They must be syntactically correct at startup, but the ordering of compilation is not important.

//Chapter 2
QHOME is needed to load q.k correctly

q needs k4.lic, by default it looks in the same dir as q.k
QLIC env variable can be usde to customise this

Q then loads q.q from QHOME
QINIT can be used to customise the init file

//2.2 Basics

#q as shebang script
#!/$QHOME/$QARCH/q
we can run ./script.q without referencing q binaries

#Redirecting the output from a separate process
When q is started interactively (q console), input is read from the STDIN file handle which is attached to the terminal.
If we redirect the output from a separate process into q's STDIN, it will accept commands from that process instead.
Once EOF is reached the q process terminates

echo '1 "hello world\n";' | q
hello world

2.3 Syntax Rules
() are not used for function invocation
f(1;2;3) creates a list and does f[(1;2;3)]

##Leading whitespaces
q continues to accumulate text for parsing until it finds another command starting flush left (no leading whitespaces)
- if we forget to indent every line of a function and q parser encounters a line that is flush left,
it assumes a new definition has begun (our function will be incomplete).

#############################Chapter3
- kdb performs type checking at runtime, a uniform list only needs its type checked a single time and not for each element,
once the type has been checked, performing arithmetic operations on uniform lists can be implemented in highly optimized C or assembly code

Using set/get to dynamically assign/access global variables (where name is only known at runtime)
 This works only for global variables
 
#All monadic k operators has been given a keyword in q e.g.
q)first
*:

internal K structure is 16 bytes (this is for non numeric data like guid)
8 bytes for metadata type,reference count, attributes
8 bytes to store an atom
8 bytes is enought to store 4 byte integer number or 8 byte long number
But in order to store the 16-byte GUID, the internal K structure must threrefore store the data as a vector of bytes.

#################Chapter 4 Functions #########################
Functions
-  can have 1-8 arguments
- niladic functions are called with (::) assigned to the x parameter, x is silently ignored

Monadic functions can be called without parameter (a parameter becomes (::))

q)f:{[a] show (::)~a;show `abc}
q)f 10
0b
`abc
q)f[]
1b
`abc
q)

- void functions return (::)
- functions can modify global state, avoid this, the good practice is to design the functions so that
  - data that needs to be modified is passed as an arg
  - modified values is passed back as a return value from the function



Function parameters
- if we reference automatic variable 'z' in the code then function will defined as 3 args func even if we don't reference x or y
- Explicitly defining function parameters prevents automatic variables (x y z) from being created
- monadic functions can be called without [] e.g. f`
- build-in q dyadic functions can use in-fix notation (x op y), this does not work for user functions
(unless they are added to the .q namespace)
- similarly to monadic functions, List and dictionaries can be indexed without [] brackets as well
This is called Juxtaposition

############## Reference Counts #################
* Q copies, assigns, and passes variables by reference (so passing big table to function has no performance overhead)
* All references point to the same underlying data structure until a modification is attempted
* Once a modification is made, new memory is allocated and the underlying structure is copied
* Any references to the original value remains unaltered
* This model is known as copy-on-write
* Q keeps track of each variable's reference count and deletes the object once the count drops to 0
* We can access the reference count with -16!x

q)a:10 20 30
q)b:a
/now both a and b point to the same object
q)-16!a
2i
q)-16!b
2i
/now we modify b so a points to original object and b points to a new object
q)b,:100
q)-16!a
1i
q)-16!b
1i

same thing when we pass var to a function
q)g:10 20 30
q)f:{[loc] show -16!g; show -16!loc; loc,:0;  show -16!g; show -16!loc;}
q)f g
2i
2i
1i
1i

Q Tip 4.4
* Use compound assignment for increased efficiency
* Each of the single character operators has a compound assignment variant

x-:avg x
x:x-avg x /slower

Q passes arguments by reference, in most cases immutable references
Updating a list creates a complete copy of the original data before modifying the structure
x-avg x

if our intention is to assign results back to x we can modify x list in place
- another way to update a data structure without creating a copy is to use "Index Apply" . or @

########Throwing Exceptions
'`myError  /using symbol
'"myError" /using strings

Vector conditional
?[;;]
- accepts a boolean or a list of booleans
- evaluates both y and z (unlikely the $ operator)
I guess this make sense, evaluation just one would work only for all 1s or all 0s case

Q Tip 5.1 Build path names by joining symbols, not character vectors
` sv separates symbols with "."
q)` sv `a`b`c
`a.b.c

` sv can separate symbols with / to create a file path
Joining a list of symbols whose first element is a handle creates a single file path (it will have platform specific separator)
q)` sv `:/tmp`dir1`dir2`file.txt
`:/tmp/dir1/dir2/file.txt

vs creates a directory handle and trailing file or subdirectory
q)` vs `:/tmp/dir1/dir2/file.txt
`:/tmp/dir1/dir2`file.txt
q)` vs `:/tmp/dir1/dir2
`:/tmp/dir1`dir2
q)


##########Namespaces#########
q)qtips.a:1
q)qtips.b:2
q)\v qtips
`s#`a`b
q)qtips
 | ::
a| 1
b| 2
q)

It is just a mapping/dictionary, ` -> :: is added automatically for us
The root namespace (value `.) is designed for data
There is another type of namespace that is designed for functions and related configuration data
These special namespaces are called directories and begin with a single dot "."

directory .qtips.a:1 vs namespace qtips.a:1

with directories we can change directory with the directory \d command
q)\d .qtips
q.qtips)a:1
q.qtips)\d .
q).qtips
 | ::
a| 1

Once in .qtips directory how do I access global a from `.  ?
value `.`a
`. `a  /juxtaposition
`.[`a] /bracket notation
`.@`a /index operator "@"

a global var is created if we define namespace or directory from within a function
q){abc.a:10}[]
q)abc
 | ::
a| 10
q)

NAMESPACES vs DIRECTORIES
- all directories are namespaces (namespaces are not directories)
- q was designed to store data in namespaces not directories (directories are for functions and related configuration)
- directories can not contain views (namespaces can!)
- automatic logging with the -l flag only records data updated in the root directory
- partitioned databases can not be loaded into directories

SCOPE FUNCTIONS WITH DIRECTORIES BUT DATASETS WITH NAMESPACES


Q Tip - Multiply instead of divide
e.g. 0.5*... instead of %2

- q has implemented vector division by an atom as multiplication by the atom's reciprocal /rI'sIpr.k.l/
- when comparing floating numbers q is using equality with tolerance (e.g. two numbers to be equal even if they differ by less than comparison tolerance t=2e-43)
https://code.kx.com/wiki/Cookbook/ComparisonTolerance
Comparison tolerance is the precision with which two numbers are determined to be equal. In q it is set to 2^-43 and cannot be changed
- two floating point numbers are considered equal if the abs difference is < than 2^-43 * larger number
- The only number equal to zero is 0
- to test for equality without tolerance ALWAYS compare with 0

q).Q.addmonths[.z.d;0 2]
2016.06.05 2016.08.05

if we have a list of pairs we can create dictionary
(!) . flip pairs
q)(!) . flip ((`a;10);(`b;20))
a| 10
b| 20

By default, a binary q operator, such as "!" is an infix dyadic verb.
That is, it must be surrounded by left and right operands or called with bracket notation.
To pass it as an argument to the dot apply operator ".", we must convert it into a noun.
- a verb must be passed a noun as an argument
- a noun can be passed as an argument to a verb

Aggregate functions can be applied to the dictionary's values but the results are no longer dictionaries

q)avg dict
103.78

DICTIONARY LOOKUPS ARE PERFORMED BY ITERATING OVER EACH KEY ELEMENT UNTIL AN EXACT MATCH IS FOUND
and the corresponding value is then returned (only the first match is returned).

Q Tip 7.1 Ensure dictionary keys are unique
- it is possible to introduce duplicate keys
- Q does not prevent us from doing this, looking up a value will only find the first occurrence of each distinct key

7.2 Tables
How tables are stored internally by kdb?

Looking at the internal representation shows us that the table is a flipped dictionary of lists
The "+" character is actually the flip operator in K
q)0N!t
+`sym`time`v!(`a`b`c;11:40:31.831 11:40:31.832 11:40:31.833;10 10 10)
sym time         v
-------------------
a   11:40:31.831 10
b   11:40:31.832 10
c   11:40:31.833 10
q)

Using flip on a dictionary of lists does not transpose the data.
It only records the fact that the data should be treated as a table.

We can flip dict to table if
- the keys of the dict must be symbols
- each of the list must be of equal size or be an atom which can be coerced into a list /kəʊˈɜːs/ wymuszac


# - Taking a subset of cols table
q)enlist[`sym]#t
sym
---
a
b
c
q)

or return as lists
q)t`sym`v
a  b  c
10 10 10

2#t - first 2 rows

To take first or last few columns we can amend # with /:
table is a list of dictionaries so from each dictionary we take 2# keys and create a list of sub-dictionaries

q)2#/:t
sym time
----------------
a   11:40:31.831
b   11:40:31.832
c   11:40:31.833
q)

In memory, a kdb+ table is not a list of dictionaries, but is a flipped dictionary of lists.
And as such, the "#/:" operator merely performs the constant time operation of taking the first two columns.


7.3 Keyed Tables

converting to the keyed table

if the key columns are not in front, use xcols
2!`id`date xcols tbl

but xkey does both
`id`date xkey t

to unkey
0!tbl
() xkey tbl


Indexing the keyed table - Dictionary of tables
q)t (0;2000.01.01)
price| 100

to query multiple records
t flip (0;2000.01.01 + til 3)
price
-------
100
98
97

But flipping a list of lists reorders the data in memory
More efficient method of indexing a keyed table is to use a table instead

t ([]id:0;date:2000.01.01 + til 3)
price
-------
100
98
97

Notice only unkeyed / value table is returned

Q Tip 8.2 From functions return unkeyed tables by default
It is important that the tables being razed not be keyed
- keyed tables are dictionaries nad joining two dictinaries merges common keys
- so function should return a table then it can be run with each and results razed

8.2 Attributes
- By default, q uses a linear search algorithm to find values within lists
- Other options we have are: binary search for sorted data, or hashing algorithm for unique, grouped or partitioned data

To apply attribute we use # with on of the below symbols
`s
`u
`p
`q
`

-we can use `# to remove attributes from a list
`#list

measuring with \ts:NoOfRuns ...

Sort Attribute
- informs q to use a binary search algorithm to find the desired element(s)
- applying `s# to an unsorted list will fail ('s-fail)
- appending an item that invalidates the sorted order will remove the attribute from the list
- asc operation will apply the `s# automatically
- `s# adds no memory overhead to the process
- q never modifies a variable unless we use in-place assignment but behaviour when applying sort attribute is different e.g.
This trick is used to save memory by avoiding the need to copy the list

Binary Search
- even without the `s# attribute we can force a binary search on sorted data by using the binary search operator bin
- bin returns the index of the right operand
- if the value does not exist bin returns an index of the closest but not larger value
-if data is unsorted the results are undefined

q)10 20 30 bin 30
2
q)10 20 30 bin 25
1
q)
q)10 20 30 binr 25
2

binr returns the index of the value that exists to the right of the non-existing element

#Sorting a table
`col1`col2 xasc tbl
- Sorting routine is stable, the ordering of equal items remains constant
- xasc will add `s# on col1
- xasc can be used with `tblname to update the table directly (no data copy is needed)
- if tblname is not a global variable then we have to assign the result back to the original variable

The sort attribute is good for data that has a high number of distinct values all listed in increasing order (e.g. time)
If not sorted or there are many repeated values we can consider the remaining attributes which rely on a hashing algorithm

####Unique Attribute
We can/and sometimes should (80+ elements?) apply the `u attribute to a table that has a single column primary key
In order to do it we must apply `u on the column vector before creating the keyed table
e.g.

tbl[`id]:`u#tbl`id;
tbl:`id xkey tbl;

Index Apply
- q has a shorthand for indexing into a list, applying an operation to the elements,
and assigning the results back to the original list

@ was used as index operator to index into a list/dictionary/table
@[t;`date]

@ is also used for index apply
@[t;`date;monadicFunction]
@[t;`price;dyadictFunction;arg]

e.g.
q)@[`t;date;`u#]
`t

REMEMBER - use in-place amends to avoid unnecessary data copy
ALSO remember that these in-place amends works only with global variable names
E.g. `t must be global for the below to work
{
  ...
  @[`t;date;`u#];
 }[]

Q Tip 8.4
Use the `u attribute on dictionary keys to increase performance

By default, looking up a value in a list(and therefore a dictionary) performs a linear search through each of the keys until a match is found.
That means that keys at the end of a dictionary will have slower retrieval time than keys at the beginning

* Adding the `u attribute to the keys list changes the lookup method from a linear search to a constant time hashing algorithm.
* For small dictionaries this may make the lookup slower
* For dictionaries with around 80 elements or more, the `u attribute allows data retrieval to remain constant-time

To define this we apply `u# to the keys
q)d:(`u#keys)!values

####Partition Attribute
Like the unique attribute `u, the partition attribute `p creates a map
The map maps each unique value to a starting row index and the count

`p requires all instances of a specific value to be partitioned/clustered together. Sorting is a convenient way to partition a list

####Group attribute
Applying `g to a list causes q to create a mapping from the distinct hash values to a list of row indices.

Used in rdb `g#sym
This ensure fast query times. q updates its internal grouping map whenever new rows are added. This makes each update slower,
but ensures fast query performance.

Q Tip 8.5
Place the most descriptive column first

Performance of a table query depends on how fast q can narrow the search down to a few rows before it resorts to a linear comparison
If you must have multiple columns in the key, ensure the most descriptive identifier is first and prefer the `p over the `g attribute

adding attributes to too many columns may slow down the insert times
ALWAYS USE THE MOST DESCRIPTIVE IDENTIFIER (THE BEST FILTER) AS THE FIRST KEYED COLUMN

#What attributes to use in tables?
sattr function optimally sets attributes on tables with no key, single key or multiple keys
- If the table has a single column key, we will apply the unique attribute
- In all other cases we apply the group attribute `g.
This includes the case where there is no key and where the key has multiple columns

Sorted Multi Column Keys
- Indexing into a multi-keyed table tat has many unique values in each column of the key can become quite slow.
Once the attribute in the first column is used, a linear search is performed for the remaining columns.

To fix this we can sort the table and add a sort attribute `s to the whole key
- This can inform kdb+ that it can use a binary search algorithm for the composite key
- We have to write our own function because asc operator sorts dictionaries by value not key

kasc:{
  $[`s~attr k:key x;
    x; /return here if the key table is already sorted
    (`s#k i)!value[x]i:iasc k
   ]
 };

 The iasc operator performs the work behind both asc and xasc
 Instead of actually rearranging the order of list elements, the iasc operator returns the index
 where each properly sorted element can be found in the original list

 The asc operator uses these indices to index into the original list, thus returning a sorted copy
 The benefit of separating out this functionality is that the results of iasc can be used to sort other lists
 without having to recompute the sort order

 our kasc uses the results of iasc to reorder both the key and value tables of the supplied dictionary
 k:key x
 (`s#k i)!value[x]i

 then at the end we place sort attribute on the key

 ***check what it means to place `s on the table
 q)a:10 20 30
 q)b:`a`b`c

 q)0N!`s#([]a;b)
 `s#+`a`b!(`p#10 20 30;`a`b`c)
 a  b
 ----
 10 a
 20 b
 30 c
 q)

 /we can see applying `s# on a table does the following
 - places `s# on entire table
 - places `p# on the first column

 q)meta `s#([]a;b)
 c| t f a
 -| -----
 a| j   p
 b| s
 q)



 ##################Chapter 9 Trades and Quotes
 Minimize calls to each

 we need to sort each of the lists
 q)asc each genList each 3#5
 0 1 2 3 4
 0 1 2 3 4
 0 1 2 3 4

 we used 2 each to do that. We can use lambda or composition with @ to minimize calls to each

 1) Using lambda
 q){asc genList x} each 3#5

 2) Using composition
 q)(asc genList@) each 3#5

We use () and @ to force the creation of function composition before it is applied to each argument
- since @ operator expects another argument the contents of () can not be fully evaluated
- the results is therefore a function composition expecting a single argument
- composition - joining of 2 functions to create a third function
- the left most function must be monadic (asc)

q)type (genList@)
104h //projection
q)type (asc genList@)
105h //composition

3) Using ' composition operator
' operator can be used to create a composition (first function must be monadic)
q)'[asc;genList] each 3#5
0 1 2 3 4
0 1 2 3 4
0 1 2 3 4

9.2 Quotes
Step Function - can be created with dictionaries by applying `s# on a dictionary (not just on its key)

q)k:0N 5 10 25 50 100
q)0N!sf:`s#k!v
`s#`s#0N 5 10 25 50 100!0.01 0.05 0.1 0.25 0.5 1
   | 0.01
5  | 0.05
10 | 0.1
25 | 0.25
50 | 0.5
100| 1

q)sf 5
0.05
q)sf 6  //would gen null here without `s# on the dict
0.05
q)sf -10
0.01
q)

The sort attribute distinguishes the step function from an ordinary dictionary.
It was added in two places: on dictionary's key and on the dictionary itself
- it is the very first attribute (on dictionary) that allows the dictionary to be treated as a strep function.
When we index into the dictionary/step function, q will perform a binary search
and return the result of the bin operation rather than '?' lookup.

standard dictionary indexing is
/x - dictionary
/y - a key value
di:{value[x] key[x] ? y}

step function indexing
/x - dictionary
/y - a key value
sfi:{value[x] key[x] bin y}

The same applies to a keyed tables
We can see the `s# is applied in 3 places,
to the keyed table as a whole, in addition to the dictionary's key (a table) and also to the first column of the key
q)0N!kt:`s#([k]v)
`s#(`s#+(,`k)!,`s#0N 5 10 25 50 100)!+(,`v)!,0.01 0.05 0.1 0.25 0.5 1
k  | v
---| ----
   | 0.01
5  | 0.05
10 | 0.1
25 | 0.25
50 | 0.5
100| 1
q)

q)kt 15
v| 0.1
q)

####Adding new columns using ,' instead of update
e.g. we have table wiht `id`time`pirce columns and want to add moving averages for windows of 2 4 6
q)p:([]price:til 20)

q)w:2 4 6
q)p,'flip (`$"w",/:string w)!w mavg\: p`price
price w2   w4   w6
--------------------
0     0    0    0
1     0.5  0.5  0.5
2     1.5  1    1
3     2.5  1.5  1.5
4     3.5  2.5  2
...


#############
next - shift left
prev, xprev - shift right

using prev/shift right is very common with time series data
q)2 xprev til 5
0N 0N 0 1 2
q)

There is not xnext but we can use xprev with a negative left operand



#####
Casting Between Types
Casting between types ($) can be done with a symbol, character, or numeric representation of the type.
q)7h$0.4 2.5 3.9
0 3 4


#####

Grouping and razing

raze (...@) each q group q`id
When the eached function returns a result that is smaller than the orginally grouped table,
performance improvements can be made by generating the grouped table within the function or composition, and not outside
raze (... q@) each group q`id

This prevents a potentially large allocation of temporary memory.


####end of chapeter 9
Kdb uses the smallest value for null
The next smallest value for negative infinity
The largest value is used for positive infinity

We can see underlying representations when integer overflows
q)0Wi + (1 2 3 -1 0i)
0N -0W -2147483646 2147483646 0Wi

The boolean and byte types are the only types that do not have a null value.

vs can be used to show binary representation
q)0x0 vs 1i
0x00000001
q)0x0 vs -1i
0xffffffff


.dot apply operator "."
e.g. upsert
q)upsert
.[;();,;]

We can do drop in place
.[t;();_;i] where i is a raw to drop


############Memory allocation
When more memory is needed than exists in the pool/heap, kdb+ will allocate additional multiples of 64MB blocks.
e.g in 3.5 we see increases by 64MB each time

When the process memory limit has been reached, q will coalesce /kəʊ.əˈles/ blocks of unused memory available in the pool/heap
that are at least 64MB, and return them back to operating system. Kdb+ then tries to allocate the requested block of memory,
if is still unable to allocate it, a `wsfull error is thrown and the process dies.

- it is possible to request memory to be coalesced by using the .Q.gc[]
-in addition q can be configured to automatically release blocks of memory that are at least 64MB by setting the -g 1

Chapter 11

Generic null ::
We need to wrap it with (::) when performing operations to prevent it from being interpreted as a double assignment

W tip 1.1. Return null from update-only functions
Returning a null value prevents q from having to reference count the returned value.
In addition, when such a function is executed with a call to each,
returning a null value prevents q from allocating memory to save the result vector.


11.2. Server Sockets
When kdb+ is started from an interactive terminal, the kdb session will continue running while waiting for updates from STDIN.

When q is started as a server, where STDIN is closed, the process will exit immediately after the last command is executed.
To prevent the server from exiting we must open a server socket.

To allow the operating system to dynamically allocate the next available port,
positive and negative infinity 0W may also be used. We can then use \p to retrieve the allocated port.

##########csv files

/using * for strings
q)("JSF*";1#",") 0: `:ref.csv
/we can use space to skip a field from being read/loaded
/we can have less types than columns (most right columns are not loaded in that case)


#####string vs symbol
symbols enables text equality tests to be performed with a single pointer comparison

Symbols are stored in a global map and never deleted.
Strings however, once all references to a character vector are lost, the memory is recovered.

/generate list of strings
"\t" 0: t

To save the file to disk we use 0: again
`:ref.txt 0: "\t" 0: t

To see the data
read0 `:ref.txt /returns list of strings

Reading csv where column names are missing ("," instead of enlist ",")
Data is returned as nested list so we need to flip `mycol`mycol2! (...)


###########Q TIP 11.9 Pass event dates and times as parameters instead of using .z.D or .z.p

Time is often an input to calculations. Function which takes time as parameter is much more flexible, reusable, testable

####################################Chapter 12 Security
uthentication Username and Password
A username and password are sent (in clear text) during the initial handshake with clients.
It is up to the server to decide if the values should be checked and if are acceptable to allow a connection

The values are ignored by default, to enable the check we need to start q process with a -u flag
followed by the name of the password file

The password can either be in clear text or encoded with the md5 hashing function

q -u ../passwords.txt -p 5001

now only users mentioned in passwords.txt can connect

###appending to a text file
h:hopen `:file.txt
neg[h] "line1";  /negative file handle will add trailing new line


####network
Messages that re sent over network handles are serialized for network transportation.
Upon receipt, the messages are then deserialized. This happens on all network handles, except the internal handle 0.

If an error is encountered during deserialization, a `badmsg error is thrown.
-9!0x01000...
'badmsg

To help debug ill-formed network messages, kdb+ allows us to customize the bad message .z.bm callback
Prior to printing the `badmsg error, .z.bm is called with the bad byte vector. You can print the vector or save it for future inspection.

During the processing of client queries, whether from STDIN, or from a client handle,
there is a posibility that a global variable is modified.
When such an event occurs, the Value Set .z.vs event is triggered.
The event is passed two parameters: the name of the modified variable as well as a list of indices that were modified.
In the case of a full assignment, as opposed to a partial amend, the second parameter is passed the empty list().
The .z.vs event can be used for debugging and logging variable modifications.


####chapter 13 debugger

When error is generated from command line session, a debugging mode is started.

//no function used - only error is printed (no debug mode needed)
q)2+`
'type


q)0 mod `a
k){x-y*x div y}   /function receiving an error
'type
div               /function that caused the error
0                 /its arguments
`a
q.q))             /namespace where the function (reciving an error) was defined

Q Tip 13.1 Function variables default to the emtpy list () in the debugger
We can check how far a function progressed before throwing the exception by checking which variables still have the default value.

IF THE FUNCTION THAT THREW THE ERROR WAS A FEW CALLS DEEP IN THE STACK, WE MAY WANT TO DEBUG THE FUNCTION ONE LEVEL ABOVE.
TO RISE ONE LEVEL IN THE STACK, WE CAN USE THE "'" COMMAND

IF HOWEVER, WE PREFER TO LET THE CODE CONTINUE BY PROVIDING A VALID RETURN VALUE,
WE CAN EXIT THE FUNCTION BY ENTERING A COLON ":" OPTIONALLY FOLLOWED BY THE DESIRED RETURN VALUE.

13.2 Trapping Errors
There are cases where the process causing the error is another q instance
or even a compiled library interfacing with the running q process.
In either of these two cases, the error message is printed to stdout, but the debugging session is not initiated.

To force debugging mode, we must be running in console mode and turn on the error trapping flag with the \e 1
(e.g. error thrown from .z.ts will only be printed....using \e 1 will cause the q process to stop in debugging mode

13.3 Breakpoints
Conditional breakpoints
Sometimes invalid values only occur under special conditions. For these cases, we can create condition breakpoints.
We can force q to only enter the debugging session when our special condition is met

q)f:{if[null x;break]; x+y}
q)f . 1 2
3
q)f . 0n 2
{if[null x;break]; x+y}
'break
q))x
0n
q))y
2f
q))


###########14 qsql
select id,date,px:price from t

It is important to realize that even though we created a new table by selecting data from t,
we did not actually make a full copy of the data.

Kdb+ is a column oriented database, and as such, columns are contiguous blocks of memory that can be passed as references.
---
Q Tip 14.3 Use De Morgan's Laws to optimizewhere clauses
select from t where (id=1) or date.month=2000.02m

An inefficient or statement can be easily converted to use a comma by negating each of the conditions
and replacing the select with delete

Laws
not (A or B) is the same as not(A) and not(B)

so A or B -> not not (A or B) -> not(not(A) and not(B))

select .... where A or B
is same as
delete ..... where not(A), not(B)

----by clause
select avg price by id from t

update ret:deltas[0n;log price] by id from t

The by clause performs three actions
1) groups the data using the columns in the by clause
2) Iterates over each group(distinct value) and applies our function
3) Final step depends on whether we used a select or update
select - will sort the results (returns keyed table)
update - does not return a keyed table, will align the results to match the location of the original layout

e.g. notice only one raw with id=0 in the select results
and multiple entries with id=0 in the update case (result of update by is not keyed table)

q)t
id date       price
----------------------
0  2000.01.01 100
0  2000.01.02 100.0632
0  2000.01.03 100.122
...

q)select avg price by id from t
id| price
--| --------
0 | 85.8896
1 | 111.7553
2 | 56.75649
3 | 119.7042
4 | 96.39676
q)

q)update ret:deltas[0n;log price] by id from t
id date       price    ret
------------------------------------
0  2000.01.01 100
0  2000.01.02 98.99257 -0.01012537
0  2000.01.03 99.00905 0.0001664493
0  2000.01.04 98.0201  -0.01003867
...

The results of the select query have the `s# or `p# attribute on the first column

q)meta select avg price by id from t
c    | t f a
-----| -----
id   | j   s
price| f

q)meta select avg price by id,date from t
c    | t f a
-----| -----
id   | j   p
date | d
price| f
q)

In both cases (by one or multiple cols) the key table is sorted / has got `s#
q)0N!select avg price by id from t;
(`s#+(,`id)!,`s#0 1 2 3 4)!+(,`price)!,85.8896 111.7553 56.75649 119.7042 96...
q)0N!select avg price by id,date from t;
(`s#+`id`date!(`p#0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0..
q)


[LK]
Noticed we used aggregate function for select by
and uniform function for update by

dot notation
by date.week
by `week$date
The functionality is the same but you will notice q changes the column name when dot notation is used.
In either case you can choose the column name yourself


We can cast to integers too
All integer casts (notice uu for the minute int cast)
q)`year`mm`dd`hh`uu`ss$\:2001.09.11D08:46
2001 9 11 8 46 0i
q)

dot notation can be used on global variables only
q)tm:0D
q)tm.minute
00:00
q)

dod notation does not work on function parameters or variables. Because of that it is safer to always use
explicit casting instead of using dot notation
`minute$x


---
###########################Exec
select is special case of exec
select always return table
exec can return atom, list dictionary, table

/atom
q)exec first price from t
100f

/list
q)exec price from t
100 98.99257 99.00905 98.0201 97.22984 97.22211 97.48342 96.53205 96.89755 96..

/same but as dictionary
q)exec px:price from t
px| 100 98.99257 99.00905 98.0201 97.22984 97.22211 97.48342 96.53205 96.8975..

/dictionary
q)exec id,date,price from t
id   | 0          0          0          0          0          0          0   ..
date | 2000.01.01 2000.01.02 2000.01.03 2000.01.04 2000.01.05 2000.01.06 2000..
price| 100        98.99257   99.00905   98.0201    97.22984   97.22211   97.4..

---
The select statement is a layer around exec that, in addition to providing optimizations for querying large historical databases,
flips the result of exec.

q)flip exec id,date,price from t
id date       price
----------------------
0  2000.01.01 100
0  2000.01.02 98.99257
...

BUT EXEC CAN RETURN FOUR MORE TYPES OF DICTIONARIES, DEPENDING ON THE TYPE OF THE KEY AND VALUE.

1) Using a single column in both the key and value generates a simple dictionary
q)exec last price by date from t where id=0
2000.01.01| 100
2000.01.02| 98.99257
2000.01.03| 99.00905
2000.01.04| 98.0201
2000.01.05| 97.22984
2000.01.06| 97.22211

2) Selecting multiple values in either the key or value, or explicitly providing a name generates a table.

q)exec price by date:date from t where id=0
q)exec price:price by date from t where id=0
q)exec price:price by date:date from t where id=0
q)exec px:last price by id,date from t where id=0

#####################Exec by

We have seen how q returns the last row of every key when a select by query does not specify any columns.

By performing an exec by query we can apply any operation across multiple columns.

For example, instead of selecting the first date and price for every ID
q)select first date, first price by id from t
id| date       price
--| ----------------
0 | 2000.01.01 100
1 | 2000.01.01 100
2 | 2000.01.01 100
q)

We can exec a table and use first operator a single time.
q)exec first ([]date;price) by id:id from t
id| date       price
--| ----------------
0 | 2000.01.01 100
1 | 2000.01.01 100
2 | 2000.01.01 100
q)

This works because calling first on the table creates a dictionary.
The by clause causes one dictionary to be created for each id, and the resulting list of dictionaries is then promoted to a table.

Q Tip 14.6 Simplify queries by using exec by


---
When the result of each statement within an exec by query is a dictionary with conforming keys that are symbols, q will promote the list of dictionaries to a table.

TO GENERATE A DICTIONARY WE CAN EITHER PERFORM A SINGLE OPERATION ON A TABLE,
OR ASSIGN A KEY TO A FUCNTION THAT RETURNS MULTIPLE VALUES.

e.g. ohlc function
We are prerforming a list of functions on the same dataset
q)select o:first price, h:max price, l:min price , c:last price by id,date from t
id date      | o        h        l        c
-------------| -----------------------------------
0  2000.01.01| 100      100      100      100
0  2000.01.02| 103.0084 103.0084 103.0084 103.0084
0  2000.01.03| 104.5936 104.5936 104.5936 104.5936
0  2000.01.04| 103.8289 103.8289 103.8289 103.8289
0  2000.01.05| 103.7782 103.7782 103.7782 103.7782
0  2000.01.06| 103.4662 103.4662 103.4662 103.4662

q)ohlc:{`o`h`l`c!(first;max;min;last)@\:x}
q)exec ohlc price by id,date from t
id date      | o        h        l        c
-------------| -----------------------------------
0  2000.01.01| 100      100      100      100
0  2000.01.02| 103.0084 103.0084 103.0084 103.0084
0  2000.01.03| 104.5936 104.5936 104.5936 104.5936
0  2000.01.04| 103.8289 103.8289 103.8289 103.8289
0  2000.01.05| 103.7782 103.7782 103.7782 103.7782


---
################14.2 Pivot Tables
q)"i"$.util.pivot 2!select date,id,price from t
date      | 0   1   2
----------| -----------
2000.01.01| 100 100 100
2000.01.02| 103 104 99
2000.01.03| 105 103 100
2000.01.04| 104 106 98

Q Tip 14.8 Only transform tables into pivot tables for presentation

Generating of a pivot table should be one of the last steps in any analysis. Adding an extra summary column and row at the end
and bottom of the table is probably the only adjustment we are likely to make to our pivot table.

When deciding which field to place in the column headers (date or id?)) - we should place the field with the fewest distinct items tin te column headers (so id not date)

Our pivot table takes single argument a keyed table
It derives all configuration parameters from the incoming table.

1) using exec by crete a dictionary
q)exec id!price by date from t
2000.01.01| 0 1 2!100 100 100i
2000.01.02| 0 1 2!103 104 99i
2000.01.03| 0 1 2!105 103 100i
2000.01.04| 0 1 2!104 106 98i

2) turn it into a table by giving name to the key
q)exec id!price by date:date from t
date      |
----------| ------------------
2000.01.01| 0 1 2!100 100 100i
2000.01.02| 0 1 2!103 104 99i
2000.01.03| 0 1 2!105 103 100i
2000.01.04| 0 1 2!104 106 98i

And to promote the list of dictionaries to a table we need to convert the keys to symbols
q)exec (`$string id)!price by date:date from t
date      | 0   1   2
----------| -----------
2000.01.01| 100 100 100
2000.01.02| 103 104 99
2000.01.03| 105 103 100
2000.01.04| 104 106 98


These are the basic operations
1) use exec by and give name to the key to get a table
2) make sure the pivot column names are symbol

This will not work if we are missing some values and dictionaries do not conform
e.g. when we remove id=0 for 2000.01.01
q)exec (`$string id)!price by date:date from 1_t
date      |
----------| -------------
2000.01.01| `1`2!100 100i
2000.01.02| `0`1`2!103 104 99i
2000.01.03| `0`1`2!105 103 100i

That's why we must ensure each dictionary has the same number, and ordering, of elements.

We can do this by first constructing a unique list of ids and then use take operator on the dictionary so that
null is returned for missing cases

q)u:`$string distinct t`id
q)exec u#(`$string id)!price by date:date from 1_t
date      | 0   1   2
----------| -----------
2000.01.01|     100 100
2000.01.02| 103 104 99
2000.01.03| 105 103 100

---

###############
select[5] from t /first 5 rows, works for memory and splayed tables only
select[-5] from t /last 5 rows
select[5 2] from t /returns 2 rows, 5 is the initial row number

####Sorting
Instead of using xasc and xdesc to sort a table after it has been created, we can specify which comparison
operation to use at the time of table selection.
Using this technique is useful when the sorting criteria is not an existing column in the table
q)select[< abs price] from t   /sort by absolute price (ascending)

To sort by multiple columns
/sort descending by date but ascending by ID
q)select[>([]date;neg id)] from t

/we can combine the row selection and sorting
q)select[5 5;>([]date;neg id)] from t

