//Chapter 1

The scripting language and the database are both running q programs,
a q function defined in a script can be sent to the database where it is evaluated and then only the results are returned.
This is a reversal of the paradigm where data is brought to the analytics.
With q, analytics can be sent to the data.

When the results of a vector operation are used as the inputs of the next operation,
all the data stored in the CPU's memory cache can be accessed immediately without needing
to search in the slower/larger caches or even the slowest and largest RAM memory located on the motherboard.

1.2. What is Q
I will reserve the term operator for any function that is provided by the q language (implemented in C or in q)

1.3 Programming Paradigms
* Q is interpreted because it requires no compilation phase.
ALL FUNCTIONS are compiled into bytecode at run time.
Definitions are compiled at startup and are lazily resolved.
They must be syntactically correct at startup, but the ordering of compilation is not important.

* Q is dynamic in both function definition and variable types (both can be changed at runtime).
This flexibility adds a runtime penalty as both the function def and variable type must be checked for each function call 
* array/vector programming language

* functional (but not pure functional)

* Kdb+ processes can be written as event handlers. Without concurrency, all q functions run in a single main thread.
To enable interaction with other processes q implements the reactor design pattern.
It demultiplexes the concurrent messages and synchronously invokes callbacks.
Responding to multiple asynchronous events allows kdb+ processes to be used as a Complex Event Processor



//Chapter 2
.Q.res - The list of operators defined in C
q).Q.res
`in`within`like`bin`binr`ss`if`do`while`exec`select`insert`update`delete`avg`..

s.k (not used in 3.7) - implementation of an SQL interface for ODBC clients
QHOME is needed to load q.k correctly

In kdb banner, the number of licensed cores appear within the parentheses (
It is possible to reduce the number of cores visible to the q binary on Linux by changing the CPU affinity
with the taskset utility.

q needs k4.lic, by default it looks in the same dir as q.k
QLIC env variable can be usde to customise this

Q then loads q.q from QHOME
QINIT can be used to customise the init file

q web server can return files such as crossdomain.xml or favicon.ico
They can be placed in a QHOME/html (different location can be set with .h.HOME)

//2.2 Basics

#Exiting from Q
- EOF (Ctrl-d Unix / Ctrl-z Windows) exits q session

#q as shebang script
#!/$QHOME/$QARCH/q
we can run ./script.q without referencing q binaries

#toString to console format
- to print the data to console q uses .Q.s

#Redirecting the output from a separate process
When q is started interactively (q console), input is read from the STDIN file handle which is attached to the terminal.
If we redirect the output from a separate process into q's STDIN, it will accept commands from that process instead.
Once EOF is reached, the process will terminate

echo '1 "hello world\n";' | q
hello world

#using k code
\ will switch to k mode
in the source file use k) e.g.
k)myfunc:{...};

\ - exit into k) or exit into q
\ - exit one layer of debuging
\ - exit multi-line comment
\ - exit parsing of source file (everything below are comments)

############################ 2.3 Syntax Rules
k was designed to be an APL-like language but written completely with the ASCII character set.
That's why a lot of operators is overloaded

{} braces or curly brackets
[] brackets
() /pəˈrɛnθɪsɪs/

() are not used for function invocation
f(1;2;3) creates a list and does f[(1;2;3)]


#Operator precendence /ˈprɛsɪd(ə)ns,prɪˈsiːd(ə)ns/ - there is none, statements evaluated from right to left
(2*3)+4 -> 4+2*3
() are used to enforce operator precedence

##Leading whitespaces
q continues to accumulate text for parsing until it finds another command starting flush left (no leading whitespaces)
- if we forget to indent every line of a function and q parser encounters a line that is flush left,
it assumes a new definition has begun (our unction will be incomplete).


#############################Chapter3
Fundamentally, q has two data types: atoms and lists
- dictionaries and tables are internally represented as combinations of lists
- uniform lists (all the values of a list are the same type) aka vectors 
- kdb performs type checking at runtime, a uniform list only needs its type checked a single time and not for each element,
once the type has been checked, performing arithmetic operations on uniform lists can be implemented in highly optimized C or assembly code

 Atomic functions
 A function is called atomic if it operates on a list of values as if the function was applied to each of the list elements
 
 All arithmetic operators are atomic
 
 #List Length
 Vectors and Non-uniform lists - In all cases, the length of the list is known at all times and stored alongside the data.
 count operator does not count the list items
 With atoms and non-list types, count is 1
 
 #page 24, List Syntax
 Using til to generated ordered int data
 
 Using set/get to dynamically assign/access variables (where name is only known at runtime)
 This works only for global variables
 q)test:2
q){test:20; get `test}[]
2

#Aggregating Functions
An aggregating function always reduces the dimension of the data supplied as its operand
list -> atom
matrix -> list

q)prd 1 2 3
6

3.3 Numeric Random data
5?10 -> range [0;9]
5?0i -> range all integers
5?10f -> range (0.0;10.0)

random numbers no duplicates/replacements
-10?10 (note negative -10)

with temporal types range is
00:00 - 23:59
00:00:00 - 23:59:59
00:00:00.000 - 23:59:59.999
2000.01.01 - 2013.12.31 (1 leap year cycle 1461 days = 1+365x4

q)-11?10
'length /we can't generate 11 distinct integers in that range

* for distinct temporal types we have to cast from integers

q)`minute$-3?10
00:08 00:02 00:04

rand - Singe random value
If X is an atom 0, it returns a random value of the same type in the range of that type:
q)rand each 3#0h                            / random short
-16351 -10827 24386h

If X is a positive number, it returns a random number of the same type in the range [0,X)
q)rand 10
9
q)rand
k){*1?x} /first 1?x


#All monadic k operators has been given a keyword in q e.g.
q)first
*:

last is implemented in C
q)last
last

3.4 Non numeric Random Data
It's not ordered so we don't supply max but null

0Nc or " " for chars
q)10?0Nc
"gtooltofin"

q)rand 0Ng
ee846e93-69c9-8697-52cb-20d9f12c9963 //internally vector of bytes

internal K structure is 16 bytes
8 bytes for metadata type,reference count, attributes
8 bytes to store an atom

To see an atom byte representation
q)0x0 vs 2h   /vector from scalar
0x0002 /short is 2 byte integer number (int16)
integer is int32
long is int64

scalar from vector
q)0x0 sv 0x0002
2h

Random Symbols
q)2?`8 /8 is max length, will get error for 2?`9
`ojjoidhe`bjchodnd  ->[a;p] sample from first 16 characters

Generating strings from predefined lists
q)5?.Q.A
"XMMCE"

.Q.a .Q.A - lower and upper case letters
q).Q.n
"0123456789"
q).Q.nA
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
q).Q.an
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789"

q).Q.b6 - all characters used in 64 encoding
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

3.5
Random seed \S
q)5?10
8 1 9 5 4
q)\S
-314159i
q)5?10
6 6 1 8 5
q)\S -314159i
q)5?10
8 1 9 5 4
q)

If we start Q again we get the same
q)5?10
8 1 9 5 4

system"S" -> system prepends \ for us
\S

system"pwd" /when using os commands we get list of strings, one per row

#################Chapter 4 Functions #########################
Functions
-  can have 1-8 arguments
- niladic functions are called with (::) assigned to the x parameter, x is silently ignored
- void functions return (::)
- functions can modify global state, avoid this, the good practice is to design the functions so that
  - data that needs to be modified is passed as an arg
  - modified values is passed back as a return value from the function
  
  Code like that is easier to maintain
  Functions like that can be executed in parallel (performance gain), they don't modify a global state

* Tip - rearrange operators to reduce the need for parentheses

Function parameters
- if we reference automatic variable 'z' in the code then function will defined as 3 args func even if we don't reference x or y
- Explicitly defining function parameters prevents automatic variables (x y z) from being created
q)f:{z*z}
q)f 3
{z*z}[3]
q)f[1;2;3]
9
q)f:{[z]z*z}
q)f 3
9
- monadic functions can be called without [] e.g. f`
- build-in q dyadic functions can use in-fix notation (x op y), this does not work for user functions (unless they are added to the .q namespace)
- similarly to monadic functions, List and dictionaries can be indexed without [] brackets as well
This is called Juxtaposition

############## Reference Counts #################
* Q copies, assigns, and passes variables by reference

* All references point to the same underlying data structure until a modification is attempted

* Once a modification is made, new memory is allocated and the underlying structure is copied

* Any references to the original value remains unaltered

* This model is known as copy-on-write

* Q keeps track of each variable's reference count and deletes the object once the count drops to 0

* We can access the reference count with -16!x

q)a:10 20 30
q)b:a
/now both a and b point to the same object
q)-16!a
2i
q)-16!b
2i
/now we modify b so a points to original object and b points to a new object
q)b,:100
q)-16!a
1i
q)-16!b
1i
q)

//example with tables
C:\Users\Lukasz>q
KDB+ 3.6 2019.04.02 Copyright (C) 1993-2019 Kx Systems
q)a:10 20 30
q)b:`a`b`c
q)-16!a
1i
q)t1:([]a;b)
q)-16!a
2i
q)t2:t1
q)-16!t1
2i
q)-16!a  //both table variables point to the same object
2i
q)update b:`aa`bb`cc from `t2
`t2
q)-16!a  //now table variables point to the different objects but both table objects point to the same 'a' vector
3i
q)

#############Cut################
x cut list - cuts the list into matrix with x columns
q)2 cut til 6
0 1
2 3
4 5

sum on matrix
q)sum 2 cut til 6
6 9

/sum is like +/
0 1 + 2 3 = 2 4   + 4 5 =6 9

(0 1)+(2 3)+(4 5)=6 9

q).stat.u12:{-6f+sum x cut (12*x)?1f}
q)avg .stat.u12 10000
-0.004159518
q)sdev .stat.u12 10000
1.009156
q)

dev, var, cov - calculate population deviation, variance and covariance (odchylenie standardowe w populacji?)
sdev, svar, scov - sample dev var and cov (odchylenie standardowe z proby?)
- include Bessel's correction to compute a more accurate estimation of a sample's deviation
- and an unbiased estimate of its variance and covariance

Skew and Kurtosis - see the formulas 
Skew - 3rd order central moment
Kurtosis - 4th order central moment

Q Tip 4.4
* Use compound assignment for increased efficiency
* Each of the single charactre operators has a compound assignment variant

x-:avg x
x:x-avg x /slower

Q passes arguments by reference, in most cases immutable references
Updating a list creates a complete copy of the original data before modifying the structure
x-avg x

if our intention is to assign results back to x we can modify x list in place
- another way to update a data structure without creating a copy is to use "Index Apply" . or @

NOTE - I don't see speed improvement when measuring time with \ts
x:`float$til 10000
\ts:10000 x:x-avg x  //64 131344j

x:`float$til 10000
\ts:10000 x-:avg x  //62 131232j

4.2 Box-Muller

Q Tip 4.5 Limit control flow statements to a single line (to help with debugging)
the only way to debug a q function is to evaluate its lines - one by one. If control flow statement (fi,while,do)
span multiple lines, it is not possible to evaluate them by copying and pasting the lines.
- if the code block becomes too long to fit on a single line, then move the body to a new function

########Throwing Exceptions
'`myError  /using symbol
'"myError" /using strings

take and drop
q)til 5
0 1 2 3 4

q)2#til 5
0 1
q)2_til 5
2 3 4

q)-2#til 5
3 4
q)-2_til 5
0 1 2

It is also possible to drop an item from within a list (with a given index)
q)0 1 2 3 4_3
0 1 2 4
q)

q)a:til 5
q)a _3    //a_3 does not work cause a_3 is valid literal name(underscore can be used in variable name)
0 1 2 4

# as shape to build n x m matrix
q)2 3 # til 10
0 1 2
3 4 5
q)

q)2 0N # til 10
0 1 2 3 4
5 6 7 8 9
q)0N 2 # til 10
0 1
2 3
4 5
6 7
8 9
q)

_ as cut

q)0 3 5 8 _ til 10
0 1 2
3 4
5 6 7
8 9
q)0 3 5 8 cut  til 10
0 1 2
3 4
5 6 7
8 9
q)

4.3

sv computes horner's rule (it evaluates Y to base X)
1*10^2 + 5*10^1 + 9*10^0
q)10 sv 1 5 9
159

X may be a list. For example, to convert days, hours, minutes, seconds to seconds:
q)0 24 60 60 sv 2 3 5 7   / 2 days, 3 hours, 5 minutes, 7 seconds
183907

2*24*60*60+3*60*60+5*60+7


/ over adverb
changes a dyadic function into a monadic function that takes a single list of values
- function takes previous value as the first argument and the second will be the next value from the list
f/[arg;L]		 // f[arg;L0; then f[pr;L1] ...
-other languages refer to this process as fold, reduce or accumulate
- only the final value is returned
- scan \ returns all intermediate values (very useful for debugging

Exponentially weighted moving average

SMA - Simple moving average, each data point is weighted equily
20 points SMA - Add the price of last 20 point and divide by 20

EMA - Exponential Moving Average
The weighting of each data point is not equal
More weight is given to the most recent data
The weighting decreases as you go further back in time
EMA treats more recent data as more relevant and more important

old pre 3.1 implementation
x-decay factor
y- list of observations

ewma:{{(y*1-x)+z*x}[x]\[y]}
/rearanging opperations
ewma:{{y+x*z-y}[x]\[y]}

over with 3 args
ewma:{{x+y*x}\[first y;1-x;x*y]}

using decay factor as if it was a function (since 3.1)
0 (.9)\ til 5
ewma:{first[y](1f-x)\x*y}


Vector conditional
?[;;]
- accepts a boolean or a list of booleans
- evaluates both y and z (unlikely the $ operator)


#################################################Chapter 5
Code organization

Building the path by using scalar from vector
q)"/" sv ("/tmp";"stat.q")
"/tmp/stat.q"

Q Tip 5.1 Build path names by joining symbols, not character vectors

` sv separates symbols with "."
q)` sv `a`b`c
`a.b.c

` sv can separate symbols with / to create a file path
Joining a list of symbols whose first element is a handle creates a single file path (it will have platform specific separator)
q)` sv `:/tmp`dir1`dir2`file.txt
`:/tmp/dir1/dir2/file.txt

vs creates a directory handle and trailing file or subdirectory
q)` vs `:/tmp/dir1/dir2/file.txt
`:/tmp/dir1/dir2`file.txt

q)` vs `:/tmp/dir1/dir2
`:/tmp/dir1`dir2
q)

####File existence with key
key `:file /returns () if file does not exist
key `:directory /returns () or list of symbols or `symbol$() if empty

IDENTITY VS EQUALITY
~ match is not tolerant when comparing different types
q)0=0f
1b
q)0~0f
0b
q)

####hsym
hsym prepends : to the symbol to create file/network handle

q)hsym `abc
`:abc

Operators relating to the handles start with leading "h"
hopen hclose hdel hcount hsym

NAMESPACES AND DIRECTORIES!!!

QINIT file - q loads the content of the QINIT file on startup
if QINIT is not defined q attempts to load file named q.q

Namespaces
q)qtips.a:1
q)qtips.b:2
q)\v qtips
`s#`a`b
q)qtips
 | ::
a| 1
b| 2
q)

It is just a mapping/dictionary, ` -> :: is added automatically for us

The root namespace (value `.) is designed for data

There is another type of namespace that is designed for functions and related configuration data

These special namespaces are called directories and begin with a single dot "."

Single letter directories are reserved for q

These are all directories loaded from q.k
q)key `
`q`Q`h`j`o

.q - all functions which are implemented in k
.Q - utility function for db maintenance
.h - functions for q's builtin web server
.j - jason functions
.o - odbc connectivity

directory .qtips.a:1 vs namespace qtips.a:1

with directories we can change directory with the directory \d command
q)\d .qtips
q.qtips)a:1
q.qtips)\d .
q).qtips
 | ::
a| 1
q)

Once in .qtips directory how do I access global a from `.  ?
value `.`a
`. `a  /juxtaposition
`.[`a] /bracket notation
`.@`a /index operator "@"

a global var is created if we define namespace or directory from within a function
q){abc.a:10}[]
q)abc
 | ::
a| 10
q)

NAMESPACES vs DIRECTORIES
- all directories are namespaces (namespaces are not directories)
- q was designed to store data in namespaces not directories
- directories can not contain views
- automatic logging with the -l flag only records data updated in the root directory
- partitioned databases can not be loaded into directories

SCOPE FUNCTIONS WITH DIRECTOREIS BUT DATASETS WITH NAMESPACES


importing
q)use `.stat.skew
`.

x - symbol e.g. `.stat (whole directory) or `.stat.skew
use:{
   system["d"]  /returns current directory as a dictionary
    upsert
      $[99h=type v:get x; v; (-1#` vs x)!1#v]
 };
 
 q)-1#` vs `.stat.f
,`f

we upsert `f!{} dictionary

#######################$ conditional operator
$[;;]
$[;;...;] - if there are fourth and fifth blocks then the third is treated as an else if condition

Chapter 6 A random walk

Q Tip - Multiply instead of divide
e.g. 0.5*... instead of %2

- q has implemented vector division by an atom as multiplication by the atom's reciprocal /rI'sIpr.k.l/
- when comparing floating numbers q is using equality with tolerance
- two floating point numbers are considered equal if the abs difference is < than 2^-43 * larger number
- The only number equal to zero is 0
- to test for equality without tolerance ALWAYS compare with 0

#########UNIFORM FUNCTIONS#############
- they all end with an s
avgs deltas fills maxs mins prds ratios sums

- like atomic functions a uniform function returns
    -an atom if called with an atom
    -a list of equal length if called with a list
    
prd - aggregation function (return last value only)
prds - uniform function (returns all intermediate results)

other aggregation functions
avg max min prd sum

deltas - each element is the difference between itself and the prior value
ratios- each element is the ratio of itself and the prior value
fills - each element is filled with previous value (nulls are filled, not nulls are unchanged)



###################6.2 Temporal Data
date
time types (minute, second, time(ms), timespan(ns)
minute, second, time are 4-byte integers
timespan is 8-byte integer

timespan like other time data types is a number that represents a window of time
When te value is less than one day it can represent a specific time of day

example when the day is rolled
q)0D23:59:59+`minute$2
1D00:01:59.000000000

###date and time
old type - datetime, 8-byte double (don't use)
new type - timestamp

Q Tip 6.3 Use timestamps instead of datetimes

Where the timespan indicates a duration, the timestamp indicates a specific time
Logically, Subtracting 2 timestamps results in a timespan

6.3 Path gen
- all mathematical operators are atomic (they work with both atoms and vectors

Q tip 
Use the dyadic form of deltas, ratios, differ and prev
defaults are 0, 1, :: and ON respectively
deltas[0;]
ratios[1;]
differ[::;]
prev[0N;]

/deltas to see number of days between dates
q)L:2016.06.05 2016.06.08 2016.06.11
q)deltas L / 0 is 2000.01.01
6000 3 3i
q)deltas[first L;L]
0 3 3i
q)

/prev is like right shift?

q)prev 2 3 5 7 11
->    0N 2 3 5 7
q)prev[0; 2 3 5 7 11]
->        0 2 3 5 7

Ranges

q).Q.addmonths[.z.d;0 2]
2016.06.05 2016.08.05

###Projections
The act of calling a function with fewer parameters than is needed aka partial application or binding parameters


###Dot Apply

The dot operator "." accepts a multivalent function, projection or data structure as its left operand and a list as its right operand.
- it then calls the function as if it had been called with bracket notation

Chapter 7
Dictionaries
- kdb uses a pair of lists for the dctionary implementation (other languages typically use binary trees/hash tables)

e.g. to map dates to prices
dict:dt!p
- creating a dictionary from lists is a constant time operation, no data has been copied
- key, value retrieve keys and values lists

if we have a list of pairs we can create dictionary
(!) . flip pairs

By default, a binary q operator, such as "!" is an infix dyadic verb. That is, it must be surrounded by left and right operands or called with bracket notation.
To pass it as an argument to the dot apply operator ".", we must convert it into a noun.

- a verb must be passed a noun as an argument
- a noun can be passed as an argument to a verb

Q list operators are overloaded to work on dictionaries

e.g.
2#d - # takes first n elements of a dictonary
subsetOfKeys#d - # returns a dictionary with a subset of keys/values
To take a single element and return as dictionary, we have to enlist
q)(1#2000.05.02)#d
2000.05.02| 98.123

Other value modifying operators ignore the key and update the dictionary's values
Aggregate functions can be applied to the dictionary's values but the results are no longer dictionaries

q)avg dict
103.78

Indexing
- Dictionaries are indexed by value, not position
- both bracket notation and juxtaposition works

DICTIONARY LOOKUPS ARE PERFORMED BY ITERATING OVER EACH KEY ELEMENT UNTIL AN EXACT MATCH IS FOUND and the corresponding value is then returned.

For small dictionaries this can be faster than using more advanced techniques such as binary search or hashing
For bigger ones this linear search will be very slow. (see chapter 8)


Assignment
- to update we can assign directly
d[key]:newValue

- or join with a new dictionary that has the list of new values

Q Tip 7.1 Ensure dictionary keys are unique
- it is possible to introduce duplicate keys
- Q does not prevent us from doing this, looking up a value will only find the first occurrence of each distinct key

Creating a list with single element - enlisting
enlist a
1#a
(),a

Q Tip 7.2 Use 0N! to debug data structures and functions
- this just prints an argument and has no side effects

page 79
Namespaces revisited
directory .qtips.a:1 vs namespace qtips.a:1

namespace/directory is a dictionary that stores variables and function definitions

We can index into the directory to find the function definition
q).stat`pctile
...

q).stat.pctile

Dot notation is more strict than indexing a namespace, it throws an error if a function is missing
q).stat.missing
'.stat.missing

Indexing .stat`missing returns generic null (::) not an error

##############7.2 Tables
Table is a flipped dictionary of lists

On a list of lists, the flip operator transposes the values

Similarly, using flip on a dictionary of lists creates a list of dictionaries - a kdb table.
With kdb table we can index by row number to pull the dictionary we want

t 4
or
t[4;`price]

Table is still stored as a dictionary of lists
- Using the flip operator on a matrix does transpose the data (expensive operation)
- Using flip on a dictionary of lists does not transpose the data. It only records the fact that the data should be treated as a table.

Looking at the internal representation shows us that it is still a flipped dictionary of lists
q)0N!t
+`sym`time`v!(`a`b`c;11:40:31.831 11:40:31.832 11:40:31.833;10 10 10)
sym time         v
-------------------
a   11:40:31.831 10
b   11:40:31.832 10
c   11:40:31.833 10
q)

The "+" character is actually the flip operator in K

We can flip dict to table if
- the keys of the dict must be symbols
- each of the list must be of equal size or be an atom which can be coerced into a list /kəʊˈɜːs/ wymuszac

We can create a table by
- flipping a dict
- creating a list of dict
- define ([] c1:data) or ([] c1) if we are happy with column name = variable name

Kdb will always check a list of dictionaries to see if it can be converted to a table (keys symbols,matching column types etc)
Kdb will always convert it to dictionary of lists / table 

To get a list of columns
q)key flip t
`id`date`price

or cols operator - will work with keyed and on-disk tables
//use key flip t in tp code not the cols



# - Taking a subset of cols table
q)enlist[`sym]#t
sym
---
a
b
c
q)

or return as lists
q)t`sym`v
a  b  c
10 10 10

2#t - first 2 rows

To take first or last few columns we can amend # with /:
table is a list of dictionaries so from each dictionary we take 2# keys and create a list of sub-dictionaries

q)2#/:t
sym time
----------------
a   11:40:31.831
b   11:40:31.832
c   11:40:31.833
q)

In memory, a kdb+ table is not a list of dictionaries, but is a flipped dictionary of lists.
And as such, the "#/:" operator merely performs the constant time operation of taking the first two columns.

7.3 Keyed Tables

Keyed table is a dictionary that maps key table with value table

Just as dictionaries allow us to access values by key, a keyed table allows us to access rows by key as well

- we can define keys within ([...]
or use key ! operator on existing table to indicate the number of keyed columns
2!tbl

if the key columns are not in front, use xcols
2!`id`date xcols tbl

but xkey does both
`id`date xkey t

to unkey
0!tbl
() xkey tbl

-we can also use ! to create a keyed table as a dictionary
kt!t

Indexing the keyed table - Dictionary of tables
q)t (0;2000.01.01)
price| 100

to query multiple records
t flip (0;2000.01.01 + til 3)
price
-------
100
98
97

But flipping a list of lists reorders the data in memory
More efficient method of indexing a keyed table is to use a table instead

t ([]id:0;date:2000.01.01 + til 3)
price
-------
100
98
97

Notice only unkeyed / value table is returned

Remember keyed table is a dictionary that maps key table to value table
- dictionary maps a list of keys to a list of values
- keyed table, the list of keys is a list of dictionaries (a table)
- the list of values is a list of dictionaries (another table)

key kt
value kt 
works as expected, they return respective tables


Chapter 8.1 Looping
each - there is a loop in the underlying implementation
each left \:
each right /:
each both '

Using each left/right/both let us use infix notation with user defined functions just like builtin q operators (can't be done 
with user defined functions when they are not used with an adverb)

ungroup - can be used on a table to ungroup nested lists 
q)t
a b
--------
a 10 100
b 20 200
c 30 300
q)ungroup t
a b
-----
a 10
a 100
b 20
b 200
c 30
c 300

Q Tip 8.1 User array lookups to implement simple conditional statements

("np" t in 12 14 15h)$myTime  /cast to timestamp or timespan

or `time`date[t=14h]

When transforming the result of an if/else statement into one of two elements
it is often easier to perform an array lookup instead of $[;;]

extension to this is using signum, e.g. we want "B"(buy) "S"(sell) or " " based on the sign of the price quantity
prices 10 0 -10
"S B"1+signum 10 0 -10 

raze - creates a list by joining each of the elements of its arguments
- it reduces one layer of nesting

q)raze (10 20 30;100 200)
10 20 30 100 200

q)raze (10;(20 20;30 30);100 200)
10
20 20
30 30
100
200

Q Tip 8.2 Return unkeyed tables by default
It is important that the tables being razed not be keyed
- keyed tables are dictionaries nad joining two dictinaries merges common keys
- so function should return a table then it can be run with each and results razed

8.2 Attributes
- By default, q uses a linear search algorithm to find values within lists
- Other options we have are: binary search for sorted data, or hashing algorithm for unique, grouped or partitioned data

attr operator obtains the attribute associated with any q value, can return the below. 
To apply attribute we use # with on of the below symbols
`s
`u
`p
`q
`

-we can use `# to remove attributes from a list
`#list

Sort Attribute
- informs q to use a binary search algorithm to find the desired element(s)
- applying `s# to an unsorted list will fail ('s-fail)
- appending an item that invalidates the sorted order will remove the attribute from the list
- asc operation will apply the `s# automatically
- `s# adds no memory overhead to the process
- q never modifies a variable unless we use in-place assignment but behaviour when applying sort attribute is different e.g.

q)x:til 3
q)`u#x
`u#0 1 2
q)x    //x has not changed after applyin `u#
0 1 2
q)`s#x
`s#0 1 2
q)x    //here whe can see x has changed after applying `s#
`s#0 1 2
q)
q)`#x  //removing attributes does not change underlying x
0 1 2
q)x
`s#0 1 2

This trick is used to save memory by avoiding the need to copy the list

10?5 - left argument is an atom => random gen to get 10 items
list?10 - left argument is a list => find

measuring with \ts:NoOfRuns ...

Binary Search
- even without the `s# attribute we can force a binary search on sorted data by using the binary search operator bin
- bin returns the index of the right operand /ˈɒpərand/
- if the value does not exist bin returns an index of the closest but not larger value
- if data is not sorted the results are undefined /ʌndɪˈfʌɪnd/

q)10 20 30 bin 30
2
q)10 20 30 bin 25
1
q)
q)10 20 30 binr 25
2

binr returns the index of the value that exists to the right of the non-existing element

#Sorting a table 
`col1`col2 xasc tbl
- Sorting routine is stable, the ordering of equal items remains constant
- xasc will add `s# on col1
- xasc can be used with `tblname to update the table directly (no data copy is needed)
- if tblname is not a global variable then we have to assign the result back to the original variable

Q Tip 8.3
Use \t:n and \ts:n to time multiple runs of a single command

The sort attribute is good for data that has a high number of distinct values all listed in increasing order (e.g. time)
If not sorted or there are many repeated values we can consider the remaining attributes which rely on a hashing algorithm

- `u `g and `p attributes need extra memory and use a hashing algorithm
`u maps the value to a single index
`g maps the value to a list of indices
`p maps the value to an index and count

example          overhead            
`s#2 2 3 sorted  0                   
`u#2 4 5 unique  16*u                
`p#2 2 1 parted  (4*u;16*u;4*u+1)    
`g#2 1 2 grouped (4*u;16*u;4*u+1;4*n)

Unique Attribute

- `u is used with lists that have no duplicate entries
- q uses a hashing algorithm to find the exact index for the desired element
- 'u-fail is thrown if there are duplicates 

We can/should apply the `u attribute to a table that has a single column primary key
In order to do it we must apply `u on the column vector before creating the keyed table
e.g.

tbl[`id]:`u#tbl`id;
tbl:`id xkey tbl;

Index Apply
- q has a shorthand for indexing into a list, applying an operation to the elements,
and assigning the results back to the original list

@ was used as index operator to index into a list/dictionary/table
@[t;`date]

@ is also used for index apply
@[t;`date;monadicFunction]
@[t;`price;dyadictFunction;arg]
@[t;`price;%;100]

E.g. amend a column to add an attribute
t:@[t;`date;`u#]  //index into the list, apply operation to the list, assign the results back to the original list

but we don't have to create a new copy of the table. We can use `tblName to amend existing object
q)@[`t;date;`u#]
`t

REMEMBER - use in-place amends to avoid unnecessary data copy
ALSO remember that these in-place amends works only with global variable names
E.g. `t must be global for the below to work
{
  ...
  @[`t;date;`u#];
 }[]



Q Tip 8.4
Use the `u attribute on dictionary keys to increase performance

By default, looking up a value in a list(and therefore a dictionary) performs a linear search through each of the keys until a match is found.
That means that keys at the end of a dictionary will have slower retrieval time than keys at the beginning

* Adding the `u attribute to the keys list changes the lookup method from a linear search to a constant time hashing algorithm.
* For small dictionaries this may make the lookup slower
* For dictionaries with around 80 elements or more, the `u attribute allows data retrieval to remain constant-time

To define this we apply `u# to the keys
q)d:(`u#keys)!values

Note - attributes other than the sort one need extra memory. The extra attribute info is saved into disk when we persist the data

####Partition Attribute
Like the unique attribute `u, the partition attribute `p creates a map
The map maps each unique value to a starting row index and the count 

`p requires all instances of a specific value to be partitioned/clustered together. Sorting is a convenient way to partition a list

####Group attribute
Applying `g to a list causes q to create a mapping from the distinct hash values to a list of row indices.

Used in rdb `g#sym
This ensure fast query times. q updates its internal grouping map whenever new rows are added. This makes each update slower, but ensures fast query performance.

Performance Considerations, consider keyed table with multiple keys
To perform a table lookup, q first finds all rows in the table that match according to the first keyed column.
Once all matches are found, it is able to narrow the search for any subsequent columns in the key.
Adding an attribute on the first column of the key allows q to narrow the search (no need for linear search on all rows).
BUT ONCE THE FIRST COLUMN IS USED TO NARROW THE SEARCH, ATTRIBUTES THAT MAY EXISTS ON THE REMAINING COLUMN ARE IGNORED
A LINEAR SEARCH IS USED FOR ALL REMAINING COLUMNS

ALWAYS USE THE MOST DESCRIPTIVE IDENTIFIER (THE BEST FILTER) AS THE FIRST KEYED COLUMN

Q Tip 8.5
Place the most descriptive column first

Performance of a table query depends on how fast q can narrow the search down to a few rows before it resorts to a linear comparison

If you must have multiple columns in the key, ensure the most descriptive identifier is first and prefer the `p over the `g attribute

adding attributes to too many columns may slow down the insert times

Q Tip 8.6
Reapply attributes after filtering or deleting rows from a table
- selecting a subset or deleting rows from tables removes all attributes
- appending rows that invalidate attributes also removes them

sattr function optimally sets attributes on tables with no key, single key or multiple keys
- single column key will always have the primary identifier as the first column
- If the table has a single column key, we will apply the unique attribute
- In all other cases we apply the group attribute `g. This includes the case where there is no key and where the key has multiple columns

Sorted Multi Column Keys
- Indexing into a multi-keyed table that has many unique values in each column of the key can become quite slow.
Once the attribute in the first column is used, a linear search is performed for the remaining columns.

To fix this we can sort the table and add a sort attribute `s to the whole key
- This can inform kdb+ that it can use a binary search algorithm for the composite key
- We have to write our own function because asc operator sorts dictionaries by value not key

kasc:{
  $[`s~attr k:key x;
    x; /return here if the key table is already sorted
    (`s#k i)!value[x]i:iasc k
   ]
 };

- iasc operator determine the proper transformation needed to sort the key
The iasc operator performs the work behind both asc and xasc
Instead of actually rearranging the order of list elements, the iasc operator returns the index
where each properly sorted element can be found in the original list

The asc operator uses these indices to index into the original list, thus returning a sorted copy
The benefit of separating out this functionality is that the results of iasc can be used to sort other lists
without having to recompute the sort order

our kasc uses the results of iasc to reorder both the key and value tables of the supplied dictionary
k:key x
(`s#k i)!value[x]i 

then at the end we place sort attribute on the key

***check what it means to place `s on the table
q)a:10 20 30
q)b:`a`b`c

q)0N!`s#([]a;b)
`s#+`a`b!(`p#10 20 30;`a`b`c)
a  b
----
10 a
20 b
30 c
q)

/we can see applying `s# on a table does the following
- places `s# on entire table
- places `p# on the first column

q)meta `s#([]a;b)
c| t f a
-| -----
a| j   p
b| s
q)

*** check how this works on dictionaries
q)kasc:{$[`s=attr k:key x;x;(`s#k i)!value[x]i:iasc k]};
/we see `s# is applied on key list
q)d:0N!kasc a!b;
`s#10 20 30!100 200 300
q)d
10| 100
20| 200
30| 300
q)d 10
100
q)d 15
0N

Chapter 9 Trades and Quotes

Minimize calls to each

E.g. assume we have a function which generate a list and we can use it to generate a list of lists with each
q)genList 5
4 3 2 1 0
q)genList each 3#5
4 3 2 1 0
4 3 2 1 0
4 3 2 1 0
q)

Now we need to sort each of the lists
q)asc each genList each 3#5
0 1 2 3 4
0 1 2 3 4
0 1 2 3 4
q)

we used 2 each to do that. We can use lambda or composition with @ to minimize calls to each

1) Using lambda
q){asc genList x} each 3#5
0 1 2 3 4
0 1 2 3 4
0 1 2 3 4
q)

2) Using composition
q)(asc genList@) each 3#5
0 1 2 3 4
0 1 2 3 4
0 1 2 3 4
q)

We use () and @ to force the creation of function composition before it is applied to each argument
- since @ operator expects another argument the contents of () can not be fully evaluated 
- the results is therefore a function composition expecting a single argument
- composition - joining of 2 functions to create a third function
- the left most function must be monadic (asc)

q)type (genList@)
104h //projection
q)type (asc genList@)
105h //composition

' operator can be used to create a composition (first function must be monadic)
q)'[asc;genList] each 3#5
0 1 2 3 4
0 1 2 3 4
0 1 2 3 4

9.2 Quotes
Step Function - can be created with dictionaries by applying `s# on a dictionary (not just on its key)

q)k:0N 5 10 25 50 100
q)0N!sf:`s#k!v
`s#`s#0N 5 10 25 50 100!0.01 0.05 0.1 0.25 0.5 1
   | 0.01
5  | 0.05
10 | 0.1
25 | 0.25
50 | 0.5
100| 1

q)sf 5
0.05
q)sf 6  //would gen null here without `s# on the dict
0.05
q)sf -10
0.01
q)

The sort attribute distinguishes the step function from an ordinary dictionary.
It was added in two places: on dictionary's key and on the dictionary itself
- it is the very first attribute (on dictionary) that allows the dictionary to be treated as a strep function.
When we index into the dictionary/step function, q will perform a binary search
and return the result of the bin operation rather than '?' lookup.

standard dictionary indexing is
/x - dictionary
/y - a key value
di:{value[x] key[x] ? y}

step function indexing
/x - dictionary
/y - a key value
sfi:{value[x] key[x] bin y}

The same applies to a keyed tables
We can see the `s# is applied in 3 places,
to the keyed table as a whole, in addition to the dictionary's key (a table) and also to the first column of the key
q)0N!kt:`s#([k]v)
`s#(`s#+(,`k)!,`s#0N 5 10 25 50 100)!+(,`v)!,0.01 0.05 0.1 0.25 0.5 1
k  | v
---| ----
   | 0.01
5  | 0.05
10 | 0.1
25 | 0.25
50 | 0.5
100| 1
q)

q)kt 15
v| 0.1
q)

Rounding to the Nearest Tick

####Adding new columns using ,' instead of update
e.g. we have table with `id`time`pirce columns and want to add moving averages for windows of 2 4 6
q)p:([]price:til 20)

q)w:2 4 6
q)p,'flip (`$"w",/:string w)!w mavg\: p`price
price w2   w4   w6
--------------------
0     0    0    0
1     0.5  0.5  0.5
2     1.5  1    1
3     2.5  1.5  1.5
4     3.5  2.5  2
...


To pick only the columns we want
tbl:`id`time`price#tbl;

9.3 Trades

next - shift left
prev, xprev - shift right

using prev/shift right is very common with time series data
q)2 xprev til 5
0N 0N 0 1 2
q)

There is not xnext but we can use xprev with a negative left operand

Casting Between Types
Casting between types ($) can be done with a symbol, character, or numeric representation of the type.
q)7h$0.4 2.5 3.9
0 3 4
q)

Grouping and razing

q)id:20?10
q)id
8 1 7 2 4 5 4 2 7 8 5 6 4 1 3 3 7 8 2 1
q)group id
8| 0 9 17
1| 1 13 19
7| 2 8 16
2| 3 7 18
4| 4 6 12
5| 5 10
6| ,11
3| 14 15
q)t:([] id;v:til 20)
q)t
id v
-----
8  0
1  1
7  2
2  3
...
q)t group id
8| +`id`v!(8 8 8;0 9 17)
1| +`id`v!(1 1 1;1 13 19)
7| +`id`v!(7 7 7;2 8 16)
2| +`id`v!(2 2 2;3 7 18)
4| +`id`v!(4 4 4;4 6 12)
5| +`id`v!(5 5;5 10)
6| +`id`v!(,6;,11)
3| +`id`v!(3 3;14 15)
q)

When we use the dictionary of indices to index back into the original table,
we obtain a list of tables which we can iteratively apply a function

Grouping a table and eaching over the groups is a common operation.

raze (...func...@) each q group q`id
raze (...func... q@) each group q`id  //indexing into q within the composition

When the eached function returns a result that is smaller than the orginally grouped table,
performance improvements can be made by generating the grouped table within the function or composition, and not outside

This prevents a potentially large allocation of temporary memory.

See Chapter 10 in new file
