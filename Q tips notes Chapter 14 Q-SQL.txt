Q-SQL
Manyoperations available in q-sql can also be done with q operators, but since q-sql syntax is quite strict, q can use
a combination of lookaheads and parallelism to optimize queries on large datasets.

select id,date,px:price from t

It is important to realize that even though we created a new table by selecting data from t,
we did not actually make a full copy of the data.

Kdb+ is a column oriented database, and as such, columns are contiguous blocks of memory that can be passed as references.

A reference to a column is kept until the data is modified. When this occurs, q creates a full copy of the data.

where clauses
The clauses are each applied form left to righ
each clause is evaluated from right to left

only the rows that are selected by the first clause are passed for evaluation to the second clause and so on. 

, vs and
Using the and operator in where clause loses the short-circuit features of ","

In contrast, there is no short-circuit syntax for queries looking for rows that match either one condition or another

Q Tip 14.3 Use De Morgan's Laws to optimizewhere clauses
select from t where (id=1) or date.month=2000.02m

Laws
not (A or B) is the same as not(A) and not(B)

so A or B -> not not (A or B) -> not(not(A) and not(B))


select .... where A or B
is same as
delete ..... where not(A), not(B)

select from t where (id=1) or date.month=2000.02m
delete from t where not id=1, not date.month=2000.02m

An inefficient or statement can be easily converted to use a comma by negating each of the conditions and replacing the select with delete

Exception
If a condition relies on the result of a uniform or aggregate function, it must be placed as the first where clause.
All remaining clauses should only use atomic functions(atomic function retuns a list when called with a list).
If a second condition uses uniform or aggregate functions, the resulting table will not match the original query

Atomic - A functin that returns an atom when called with an atom, and a list when called with a list.
The return values for a given argument is always the same, regardless if it was called as an atom or a member of a list.

Uniform - Liake an atomic function, but when called with a list, the results depend on other elements within the list.
The results are therefore not the same as calling the function individually on each element of the list.

Delete statement can also be used to remove columns
q)delete id from t
We can't issue a delete statement with both columns and rows specified.
q)delete id from t where date.month=2000.02m
'nyi

'nyi (not yet implemented) indicates that the implemenation is in some way controversial.

#######################Update

By themselves select, delete update and where are simple transformations that can be achieved with standard q syntax

select id, date from t => `id`date#t

select from t where date.month=2000.02m => t where 2000.02m="m"$t`date

update func[price] from t => @t[`price;func]

but implementing the by cluse is a bit more involved.

select avg price by id from t

update ret:deltas[0n;log price] by id from t

The by clause performs three actions
1) groups the data using the columns in the by clause
2) Iterates over each group(distinct value) and applies our function
3) Final step depends on whether we used a select or update
select - will sort the results
update - will align the results to match the location of the original layout

e.g. only one entry with id=0 in the select case
and multiple entries with id=0 in the update case (result of update by is not keyed table)

q)t
id date       price
----------------------
0  2000.01.01 100
0  2000.01.02 100.0632
0  2000.01.03 100.122
...

q)select avg price by id from t
id| price
--| --------
0 | 85.8896
1 | 111.7553
2 | 56.75649
3 | 119.7042
4 | 96.39676
q)

q)update ret:deltas[0n;log price] by id from t
id date       price    ret
------------------------------------
0  2000.01.01 100
0  2000.01.02 98.99257 -0.01012537
0  2000.01.03 99.00905 0.0001664493
0  2000.01.04 98.0201  -0.01003867
...

The results of the select query have the `s# or `p# attribute on the first columnn
q)meta select avg price by id from t
c    | t f a
-----| -----
id   | j   s
price| f
q)

q)meta select avg price by id from t
c    | t f a
-----| -----
id   | j   s
price| f

q)meta select avg price by id,date from t
c    | t f a
-----| -----
id   | j   p
date | d
price| f
q)

In both cases (by one or multiple cols) the key table is sorted / has got `s#
q)0N!select avg price by id from t;
(`s#+(,`id)!,`s#0 1 2 3 4)!+(,`price)!,85.8896 111.7553 56.75649 119.7042 96...
q)0N!select avg price by id,date from t;
(`s#+`id`date!(`p#0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0..
q)

[LK]
Noticed we used aggregate function for select by
and uniform function for update by

dot notation
by date.week
by `week$date
The functionality is the same but you will notice q changes the column name wehn dot notation is used.
In either case you can choose the column name yourself

dot notation extracts a "sub" type

But we cast to integers too
All integer casts
q)`year`mm`dd`hh`uu`ss$\:2001.09.11D08:46
2001 9 11 8 46 0i
q)

dot notation can be used on global variables
q)tm:0D
q)tm.minute
00:00
q)

dod notation does not work on function parameters or variables. Because of that it is safer to always use
explicit casting instead of using dot notation
`minute$x

By Gotchas

/price is return as a list (not as atom as one may think looking at the console result)
q)select price by id,date from t
id date      | price
-------------| --------
0  2000.01.01| 100
0  2000.01.02| 98.99257
0  2000.01.03| 99.00905
...

q)meta select price by id,date from t
c    | t f a
-----| -----
id   | j   p
date | d
price| F


By not specifying any columns we get last row
select by id from t  //simpler query increased performance

###########################Exec
select is special case of exec
select always return table
exec can return atom, list ditionary, table

/atom
q)exec first price from t
100f

/list
q)exec price from t
100 98.99257 99.00905 98.0201 97.22984 97.22211 97.48342 96.53205 96.89755 96..

/same but as dictionary
q)exec px:price from t
px| 100 98.99257 99.00905 98.0201 97.22984 97.22211 97.48342 96.53205 96.8975..

/dictionary
q)exec id,date,price from t
id   | 0          0          0          0          0          0          0   ..
date | 2000.01.01 2000.01.02 2000.01.03 2000.01.04 2000.01.05 2000.01.06 2000..
price| 100        98.99257   99.00905   98.0201    97.22984   97.22211   97.4..

The select statement is a layer around exec that, in addition to providing optimizations for querying large historical databases, flips the result of exec.

q)flip exec id,date,price from t
id date       price
----------------------
0  2000.01.01 100
0  2000.01.02 98.99257
...

BUT EXEC CAN RETURN FOUR MORE TYPES OF DICTIONARIES, DEPENDING ON THE TYPE OF THE KEY AND VALUE.

1) Using a single column in both the key and value generates a simple dictionary
q)exec last price by date from t where id=0
2000.01.01| 100
2000.01.02| 98.99257
2000.01.03| 99.00905
2000.01.04| 98.0201
2000.01.05| 97.22984
2000.01.06| 97.22211

2) Selecting multiple values in either the key or value, or explicitly providing a name generates a table.

q)exec price by date:date from t where id=0
q)exec price:price by date from t where id=0
q)exec price:price by date:date from t where id=0
q)exec px:last price by id,date from t where id=0

######################Exec by

We have seen how q returns the last row of every key when a select by query does not specify any columns.

By performing an exec by query we can apply any operation across multiple columns.

For example, instead of selecting the first date and price for every ID
q)select first date, first price by id from t
id| date       price
--| ----------------
0 | 2000.01.01 100
1 | 2000.01.01 100
2 | 2000.01.01 100
q)

We can exec a table and use first operator a single time.
q)exec first ([]date;price) by id:id from t
id| date       price
--| ----------------
0 | 2000.01.01 100
1 | 2000.01.01 100
2 | 2000.01.01 100
q)

This works because calling first on the table creates a dictionary.
The by clause causes one dictionary to be created for each id, and the resulting list of dictionaries is then promoted to a table.

Q Tip 14.6 Simplify queries by using exec by

When the result of each statement within an exec by query is a dictionary with conforming keys that are symbols, q will promote the list of dictionaries to a table.

TO GENERATE A DICTIONARY WE CAN EITHER PERFORM A SINGLE OPERATION ON A TABLE,
OR ASSIGN A KEY TO A FUCNTION THAT RETURNS MULTIPLE VALUES.

e.g. ohlc function
We are prerforming a list of functions on the same dataset
q)select o:first price, h:max price, l:min price , c:last price by id,date from t
id date      | o        h        l        c
-------------| -----------------------------------
0  2000.01.01| 100      100      100      100
0  2000.01.02| 103.0084 103.0084 103.0084 103.0084
0  2000.01.03| 104.5936 104.5936 104.5936 104.5936
0  2000.01.04| 103.8289 103.8289 103.8289 103.8289
0  2000.01.05| 103.7782 103.7782 103.7782 103.7782
0  2000.01.06| 103.4662 103.4662 103.4662 103.4662

q)ohlc:{`o`h`l`c!(first;max;min;last)@\:x}
q)exec ohlc price by id,date from t
id date      | o        h        l        c
-------------| -----------------------------------
0  2000.01.01| 100      100      100      100
0  2000.01.02| 103.0084 103.0084 103.0084 103.0084
0  2000.01.03| 104.5936 104.5936 104.5936 104.5936
0  2000.01.04| 103.8289 103.8289 103.8289 103.8289
0  2000.01.05| 103.7782 103.7782 103.7782 103.7782

another example with different function with summary statistics
q)summary:{`n`mn`mx`md`dv!(count;min;max;med;sdev)@\:x}
q)exec summary price by id,date from t
id date      | n mn       mx       md       dv
-------------| -------------------------------
0  2000.01.01| 1 100      100      100
0  2000.01.02| 1 103.0084 103.0084 103.0084
0  2000.01.03| 1 104.5936 104.5936 104.5936

################14.2 Pivot Tables
q)"i"$.util.pivot 2!select date,id,price from t
date      | 0   1   2
----------| -----------
2000.01.01| 100 100 100
2000.01.02| 103 104 99
2000.01.03| 105 103 100
2000.01.04| 104 106 98

Q Tip 14.8 Only transorm tables into pivot tables for presenation

Generating or a pivot table should be one of the last steps in any analysis. Adding an extra summary column and row at the end
and bottom of the table is probably the only adjustment we are likely to make to our pivot table.

When deciding which field to place in the column headers (date or id?)) - we should place the field with the fewest distinct items tin te column headers (so id not date)

Our pivot table takes single argument a keyed table
It derives all configuration parameters from the incoming table.

1) using exec by crete a dictionary
q)exec id!price by date from t
2000.01.01| 0 1 2!100 100 100i
2000.01.02| 0 1 2!103 104 99i
2000.01.03| 0 1 2!105 103 100i
2000.01.04| 0 1 2!104 106 98i

2) turn it into a table by giving name to the key
q)exec id!price by date:date from t
date      |
----------| ------------------
2000.01.01| 0 1 2!100 100 100i
2000.01.02| 0 1 2!103 104 99i
2000.01.03| 0 1 2!105 103 100i
2000.01.04| 0 1 2!104 106 98i

And to promote the list of dictionaries to a table we need to convert the keys to symbols
q)exec (`$string id)!price by date:date from t
date      | 0   1   2
----------| -----------
2000.01.01| 100 100 100
2000.01.02| 103 104 99
2000.01.03| 105 103 100
2000.01.04| 104 106 98

These are the basic operations 
1) use exec by and give name to the key to get a table
2) make sure the pivot column names are symbol

This will not work if we are missing some values and dictionaries do not conform
e.g. when we remove id=0 for 2000.01.01
q)exec (`$string id)!price by date:date from 1_t
date      |
----------| -------------
2000.01.01| `1`2!100 100i
2000.01.02| `0`1`2!103 104 99i
2000.01.03| `0`1`2!105 103 100i

That's why we must endure each dictionary has the same number, and ordering, of elements.

We can do this by first construting a unique list of ids and then use take operator on the dictionary so that
null is returned for missing cases

q)exec u#(`$string id)!price by date:date from 1_t
date      | 0   1   2
----------| -----------
2000.01.01|     100 100
2000.01.02| 103 104 99
2000.01.03| 105 103 100
