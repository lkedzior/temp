
//function passed to the server (e.g. HDB / RDB) from the gw function
//runs the query and puts results/error msg back on to gw connection
.ipc.asyncReturn:{[q;t]
  h:.z.w;
  //.admin.token:...;
  res:@[{(1b;value x)};q;{(0b;x)}];
  //put results back to client
  @[neg[h];res;
    {[h;errorMsg].log.error"...."; neg[h](0b;errorMsg)}[h]]}
 };

.gw.dispatchCollect[queries; handlers; asynReturnFunc]{
  //dispatch queries to given handlers
  //collect results
  //return results
 };
 
userGwFunc:{[user syms cols etc]
  //retrieve handlers needed for this query
  //this is highest level user function so at this level it is acceptable to reference global variables
  handlers:...
  
  //lower level reusable lib functions should not reference global variables
  
  //this place may be good to test handlers and throw error or log error if any is NULL (depending on user use case)
  
  //define user queries
  queries:...
  
  //define asyncReturnFunc that should be used e.g.
  syncReturnFunc:.cfg.defaultAsyncReturnFunc (e.g. .ipc.asyncReturn)
  
  //delegate to dispatchCollect or to a dispatchCollectWrapper function with some additional funcionality
  res:.gw.dispatchCollect[handlers;queries; asyncReturnFunc]
  
  :res
 };


//using -30! in the gateway
//multiple clients can connect to gw at the same time usync sync mode
//gw then needs to have full async protocol with RDB and HDB
gw .z.pg

.z.pg:{
  -30!(::); //releasing the handler for other clients
  //dispatch to rdb & hdb using full async (record id and client .z.w somewhere in the table)
  //important don't block here
  //end of .z.pg
 };
 
.z.ps:{
  //process replies from the rdb & hdb
  send results back to client
  -30!(clientHandle;1b;res) 
  or -30!(clientHandle;0b;"errorString") 
 };





