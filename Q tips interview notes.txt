With q, analytics can be sent to the data.

When the results of a vactor operation are used as the inputs of the next operation,
all the data stored in the CPU's memory cache can be accessed immediately without needing
to search in the slower/larger caches or even the slowest and largest RAM memory located on the motherboard.

1.3 Programming Paradigms
* Q is interpreted because it requires no compilation phase.
ALL FUNCTIONS are compiled into bytecode at run time.
Definitions are compiled at startup and are lazily resolved.
They must be syntactically correct at startup, but the ordering of compilation is not important.

//Chapter 2
QHOME is needed to load q.k correctly

q needs k4.lic, by default it looks in the same dir as q.k
QLIC env variable can be usde to customise this

Q then loads q.q from QHOME
QINIT can be used to customise the init file

//2.2 Basics

#q as shebang script
#!/$QHOME/$QARCH/q
we can run ./script.q without referencing q binaries

#Redirecting the output from a separate process
When q is started interactively (q console), input is read from the STDIN file handle which is attached to the terminal.
If we redirect the output from a separate process into q's STDIN, it will accept commands from that process instead.
Once EOF is reached, the process will terminate

echo '1 "hello world\n";' | q
hello world

2.3 Syntax Rules
() are not used for function invocation
f(1;2;3) creates a list and does f[(1;2;3)]

##Leading whitespaces
q continues to accumulate text for parsing until it finds anohter command starting flush left (no leading whitespaces)
- if we forget to indent every line of a function and q parser encounters a line that is flush left,
it assumes a new definitiona has begun (our unction will be incomplete).

#############################Chapter3
- kdb performs type checking at runtime, a uniform list only needs its type checked a single time and not for each element,
once the type has been checked, performing arithementic oprations on uniform lists can be implemented in highly optimized C or assembly code

Using set/get to dynamically assign/access variables (where name is only known at runtime)
 This works only for global variables
 
#All monadic k operators has been given a keyword in q e.g.
q)first
*:

internal K structure is 16 bytes (this is for non numberic data like guid)
8 bytes for metadata type,reference count, attributes
8 bytes to store an atom

#################Chapter 4 Functions #########################
Functions
-  can have 1-8 arguments
- niladic functions are called with (::) assigned to the x parameter, x is silently ignored
- void functions return (::)
- functions can modify global state, avoid this, the good practice is to design the functions so that
  - data that needs to be modified is passed as an arg
  - modified values is passed back as a return value from the function

Function parameters
- if we reference autmatic variable 'z' in the code then funciton will defined as 3 args func even if we don't reference x or y
- Explicitly defining function parameters prevents automatic variables (x y z) from being created
- monadic functions can be called without [] e.g. f`
- build-in q dyadic functions can use in-fix notation (x op y), this does not work for user functions (unlsess they are added to the .q namespace)
- similarly to monadic functions, List and dictionaries can be indexed without [] brackets as well
This is called Juxtaposition

############## Reference Counts #################
* Q copies, assigns, and passes variables by reference
* All references point to the same underlying data structure until a modification is attmepted
* Once a modification is made, new memory is allocated and the underlying structure is copied
* Any references to the original value remains unaltered
* This model is known as copy-on-write
* Q keeps track of each variable's reference count and deletes the object once the count drops to 0
* We can access the reference count with -16!x

q)a:10 20 30
q)b:a
/now both a and b point to the same object
q)-16!a
2i
q)-16!b
2i
/now we modify b so a points to original object and b points to a new object
q)b,:100
q)-16!a
1i
q)-16!b
1i

Q Tip 4.4
* Use compound assignment for increased efficiency
* Each of the single character operators has a compound assignment variant

x-:avg x
x:x-avg x /slower

Q passes arguments by reference, in most cases immutable references
Updating a list creates a complete copy of the original data before modifying the structure
x-avg x

if our intention is to assign results back to x we can modify x list in place
- another way to update a data structure without creating a copy is to use "Index Apply" . or @

########Throwing Exceptions
'`myError  /using symbol
'"myError" /using strings

Vector conditional
?[;;]
- accepts a boolean or a list of booleans
- evealutate both y and z (unlikely the $ operator)

Q Tip 5.1 Build path names by joining symbols, not character vectors
` sv separates symbols with "."
q)` sv `a`b`c
`a.b.c

` sv can separate symbols with / to create a file path
Joining a list of symbols whose first element is a hndle creates a single file path (it will have platform specific separator)
q)` sv `:/tmp`dir1`dir2`file.txt
`:/tmp/dir1/dir2/file.txt

vs creates a directory handle and trailing file or subdirector
q)` vs `:/tmp/dir1/dir2/file.txt
`:/tmp/dir1/dir2`file.txt
q)` vs `:/tmp/dir1/dir2
`:/tmp/dir1`dir2
q)


##########Namespaces#########
q)qtips.a:1
q)qtips.b:2
q)\v qtips
`s#`a`b
q)qtips
 | ::
a| 1
b| 2
q)

It is just a mapping/dictionary, ` -> :: is added automatically for us
The root namespace (value `.) is designed for data
There is another type of namespace that is designed for functions and related configuration data
These special namespaces are called directories and begin with a single dot "."

directory .qtips.a:1 vs namespace qtips.a:1

with directories we can change directory with the directory \d command
q)\d .qtips
q.qtips)a:1
q.qtips)\d .
q).qtips
 | ::
a| 1

Once in .qtips directory how do I access global a from `.  ?
value `.`a
`. `a  /juxtaposition
`.[`a] /bracket notation
`.@`a /index operator "@"

a global var is created if we define namespace or directory from within a function
q){abc.a:10}[]
q)abc
 | ::
a| 10
q)

NAMESPACES vs DIRECTORIES
- all directories are namespaces (namespaces are not directories)
- q was designed to store data in namespaces not directories
- directories can not contain views
- automatic logging with the -l flag only records data updated in the root directory
- partitioned databases can not be loaded into directories

SCOPE FUNCTIONS WITH DIRECTOREIS BUT DATASETS WITH NAMESPACES


Q Tip - Multiply instead of divide
e.g. 0.5*... instead of %2

- q has implemented vector division by an atom as multiplication by the atom's reciprocal /rI'sIpr.k.l/
- when comparing floating numbers q is using equility with tolerance
- two floating point numbers are considered equal if the abs difference is < than 2^-43 * larger number
- The only number equal to zero is 0
- to test for equality without tolerance ALWAYS compare with 0
